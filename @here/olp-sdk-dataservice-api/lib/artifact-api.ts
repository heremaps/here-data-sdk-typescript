/*
 * Copyright (C) 2019 HERE Europe B.V.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * License-Filename: LICENSE
 */

/**
 * Artifact Service v1
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 *
 * Do not edit the class manually.
 */

import { RequestBuilder, RequestOptions, UrlBuilder } from "./RequestBuilder";

export interface Artifact {
    artifactId: string;
    created: Date;
    groupId: string;
    hrn: string;
    updated: Date;
    version: string;
}

export interface ArtifactFile {
    name?: string;
}

export interface DeleteArtifactResponse {
    artifact?: Artifact;
    files?: string[];
}

export interface DeleteFileResponse {
    artifact?: Artifact;
    file?: string;
}

export interface DeleteSchemaResponse {
    artifacts?: Artifact[];
    schema?: Schema;
}

export interface GetArtifactResponse {
    artifact?: Artifact;
    files?: ArtifactFile[];
}

export interface GetSchemaResponse {
    artifacts?: Artifact[];
    schema?: Schema;
    schemaValidationResults?: SchemaValidationResults[];
    variants?: Variant[];
}

export interface ListSchemasResponse {
    items?: Schema[];
    next?: string;
    page?: PagedQuery;
}

export interface PagedQuery {
    from?: string;
    limit?: number;
    order: OrderEnum;
    sort: string;
}

export type OrderEnum = "ASC" | "DESC";
export interface Principal {
    type: TypeEnum;
    token: string;
}

export type TypeEnum = "User" | "App" | "Group";
export interface RegisterArtifactRequest {
    userId?: string;
}

export interface RegisterArtifactResponse {
    artifactId?: string;
    created?: boolean;
    groupId?: string;
    hrnPrefix?: string;
}

export interface Schema {
    artifactId: string;
    created: Date;
    groupId: string;
    hrn: string;
    name: string;
    summary?: string;
    updated: Date;
    version: string;
}

export interface SchemaValidationResults {
    backwardsCompatibility?: boolean;
    fileExtension?: boolean;
    googleStyle?: boolean;
    majorVersionInPackage?: boolean;
    module: string;
    packageConsistency?: boolean;
}

export interface UpdatePermissionRequest {
    principal: Principal;
    permissions: PermissionsEnum[];
    permitted?: boolean;
}

export type PermissionsEnum = "READ" | "MODIFY" | "SHARE";
export interface UpdatePermissionResponse {
    permissions?: PermissionsEnum[];
    permitted?: boolean;
    principal?: Principal;
}

export interface Variant {
    id: string;
    url: string;
}

/* ===================================================================
 * ArtifactsApi
 */

/**
 * Requires permission to 'modifyResource' for the given HRN
 *
 * @summary Delete a specific artifact
 * @param artifactHrn The HRN of the artifact
 */
export async function deleteArtifactUsingDELETE(
    builder: RequestBuilder,
    params: { artifactHrn: string }
): Promise<DeleteArtifactResponse> {
    const baseUrl = "/artifact/{artifactHrn}".replace(
        "{artifactHrn}",
        UrlBuilder.toString(params["artifactHrn"])
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "DELETE",
        headers
    };

    return builder.request<DeleteArtifactResponse>(urlBuilder, options);
}

/**
 * Requires permission to 'modifyResource' for the given HRN
 *
 * @summary Delete a specific artifact file
 * @param artifactHrn The HRN of the artifact
 * @param fileName The path to artifact file
 */
export async function deleteFileUsingDELETE(
    builder: RequestBuilder,
    params: { artifactHrn: string; fileName: string }
): Promise<DeleteFileResponse> {
    const baseUrl = "/artifact/{artifactHrn}/{fileName}"
        .replace("{artifactHrn}", UrlBuilder.toString(params["artifactHrn"]))
        .replace("{fileName}", UrlBuilder.toString(params["fileName"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "DELETE",
        headers
    };

    return builder.request<DeleteFileResponse>(urlBuilder, options);
}

/**
 * Requires permission to 'readResource' for the given HRN
 *
 * @summary Retrieve a specific artifact file
 * @param artifactHrn The HRN of the artifact
 * @param fileName The path to artifact file
 */
export async function getArtifactFileUsingGET(
    builder: RequestBuilder,
    params: { artifactHrn: string; fileName: string }
): Promise<string> {
    const baseUrl = "/artifact/{artifactHrn}/{fileName}"
        .replace("{artifactHrn}", UrlBuilder.toString(params["artifactHrn"]))
        .replace("{fileName}", UrlBuilder.toString(params["fileName"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<string>(urlBuilder, options);
}

/**
 * @summary getArtifact
 * @param artifactHrn The HRN of the artifact
 */
export async function getArtifactUsingGET(
    builder: RequestBuilder,
    params: { artifactHrn: string }
): Promise<Response> {
    const baseUrl = "/{artifactHrn}".replace(
        "{artifactHrn}",
        UrlBuilder.toString(params["artifactHrn"])
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.requestBlob(urlBuilder, options);
}

/**
 * Requires permission to 'modifyResource' for the given HRN
 *
 * @summary Create or update a specific artifact
 * @param artifactHrn The HRN of the artifact
 * @param fileName The path to artifact file
 * @param file
 */
export async function putArtifactFileUsingPUT(
    builder: RequestBuilder,
    params: { artifactHrn: string; fileName: string; file: string }
): Promise<any> {
    const baseUrl = "/artifact/{artifactHrn}/{fileName}"
        .replace("{artifactHrn}", UrlBuilder.toString(params["artifactHrn"]))
        .replace("{fileName}", UrlBuilder.toString(params["fileName"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "PUT",
        headers
    };
    headers["Content-Type"] = "application/json";
    if (params["file"] !== undefined) {
        options.body = JSON.stringify(params["file"]);
    }

    return builder.request<any>(urlBuilder, options);
}

/**
 * Requires permission to 'apiAccess'
 *
 * @summary Register a new group and artifact
 * @param groupId The groupId of the artifact. Reversed internet domain name such as com.here.rib.schema
 * @param artifactId The ID of the artifact
 * @param registerRequest The register request
 */
export async function registerArtifactUsingPUT(
    builder: RequestBuilder,
    params: {
        groupId: string;
        artifactId: string;
        registerRequest?: RegisterArtifactRequest;
    }
): Promise<RegisterArtifactResponse> {
    const baseUrl = "/artifact/register/{groupId}/{artifactId}"
        .replace("{groupId}", UrlBuilder.toString(params["groupId"]))
        .replace("{artifactId}", UrlBuilder.toString(params["artifactId"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "PUT",
        headers
    };
    headers["Content-Type"] = "application/json";
    if (params["registerRequest"] !== undefined) {
        options.body = JSON.stringify(params["registerRequest"]);
    }

    return builder.request<RegisterArtifactResponse>(urlBuilder, options);
}

/* ===================================================================
 * SchemasApi
 */

/**
 * Requires permission to 'modifyResource' for the given HRN
 *
 * @summary Delete schema
 * @param schemaHrn The HRN of the schema
 */
export async function deleteSchemaUsingDELETE(
    builder: RequestBuilder,
    params: { schemaHrn: string }
): Promise<DeleteSchemaResponse> {
    const baseUrl = "/schema/{schemaHrn}".replace(
        "{schemaHrn}",
        UrlBuilder.toString(params["schemaHrn"])
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "DELETE",
        headers
    };

    return builder.request<DeleteSchemaResponse>(urlBuilder, options);
}

/**
 * Requires permission to 'readResource' for the given HRN
 *
 * @summary Resolve a schema doc variant URL
 * @param schemaHrn The HRN of the schema
 * @param file The path to schema file
 */
export async function getDocumentUsingGET(
    builder: RequestBuilder,
    params: { schemaHrn: string; file: string }
): Promise<string> {
    const baseUrl = "/schema/{schemaHrn}/doc/{file}"
        .replace("{schemaHrn}", UrlBuilder.toString(params["schemaHrn"]))
        .replace("{file}", UrlBuilder.toString(params["file"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<string>(urlBuilder, options);
}

/**
 * Requires permission to 'readResource' for the given HRN
 *
 * @summary Retrieve schema details
 * @param schemaHrn The HRN of the schema
 */
export async function getSchemaUsingGET(
    builder: RequestBuilder,
    params: { schemaHrn: string }
): Promise<GetSchemaResponse> {
    const baseUrl = "/schema/{schemaHrn}".replace(
        "{schemaHrn}",
        UrlBuilder.toString(params["schemaHrn"])
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<GetSchemaResponse>(urlBuilder, options);
}

/**
 * Requires permission to 'apiAccess'
 *
 * @summary List the available schemas
 * @param sort
 * @param order
 * @param from
 * @param limit
 */
export async function listUsingGET(
    builder: RequestBuilder,
    params: {
        sort?: string;
        order?: "ASC" | "DESC";
        from?: string;
        limit?: number;
    }
): Promise<ListSchemasResponse> {
    const baseUrl = "/schema";

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("sort", params["sort"]);
    urlBuilder.appendQuery("order", params["order"]);
    urlBuilder.appendQuery("from", params["from"]);
    urlBuilder.appendQuery("limit", params["limit"]);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<ListSchemasResponse>(urlBuilder, options);
}

/**
 * READ grants 'readResource', MODIFY grants 'modifyResource', SHARE grants 'shareResource'.
 * Requires permission to 'shareResource' for the given HRN.
 *
 * @summary Update schema permissions for user on the specified schema and associated artifact.
 * @param schemaHrn The HRN of the schema
 * @param updatePermissionRequest The permission request
 */
export async function updateSchemaPermissionUsingPOST(
    builder: RequestBuilder,
    params: {
        schemaHrn: string;
        updatePermissionRequest?: UpdatePermissionRequest;
    }
): Promise<UpdatePermissionResponse> {
    const baseUrl = "/schema/{schemaHrn}/permission".replace(
        "{schemaHrn}",
        UrlBuilder.toString(params["schemaHrn"])
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "POST",
        headers
    };
    headers["Content-Type"] = "application/json";
    if (params["updatePermissionRequest"] !== undefined) {
        options.body = JSON.stringify(params["updatePermissionRequest"]);
    }

    return builder.request<UpdatePermissionResponse>(urlBuilder, options);
}
