/*
 * Copyright (C) 2020 HERE Global B.V. and its affiliate(s).
 * All rights reserved.
 *
 * This software and other materials contain proprietary information
 * controlled by HERE and are protected by applicable copyright legislation.
 * Any use and utilization of this software and other materials and
 * disclosure to any third parties is conditional upon having a separate
 * agreement with HERE for the access, use, utilization or disclosure of this
 * software. In the absence of such agreement, the use of the software is not
 * allowed.
 */

/**
 * Authorization API v1.1
 *   This specification is intended to describe the Authorization v1.1 APIs
 *
 *   OpenAPI spec version: 1.1.0
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 *
 * Do not edit the class manually.
 */

import { RequestBuilder, RequestOptions, UrlBuilder } from "./RequestBuilder";

export interface PageWToken {
    /**
     * Total entities
     */
    total?: number;

    /**
     * The pageToken used to retrieve the next page of entities
     */
    pageToken?: string;

    /**
     * number of items returned
     */
    count?: number;
}

export interface Group {
    id?: string;
    hrn?: string;

    /**
     * A user defined name for the group.
     * The following characters are not allowed in the group name: control characters, non-breaking space,
     * and * / < > \\  |
     */
    name: string;

    realm?: string;

    /**
     * An optional user defined description for the group.
     * The following characters are not allowed in the group name: control characters, non-breaking space,
     * and * / < > \\  |
     */
    description?: string;
}

export interface GroupPageWToken extends PageWToken {
    data: Group[];
}

export type StateEnum = "deleted" | "disabled" | "locked" | "enabled";

export interface UserInfo {
    /**
     * The unique identifier of the user.
     */
    userId?: string;
    /**
     * The HRN of the user.
     */
    userHrn?: string;
    /**
     * A realm which the user belongs to.
     */
    realm?: string;
    /**
     * The first name of the user. Only included if entityType is user
     */
    firstname?: string;
    /**
     * The lastname of the user.  Only included if entityType is user
     */
    lastname?: string;
    /**
     * Email address of the user.  Only included if entityType is user
     */
    email?: string;
    /**
     * The status of this user.
     */
    state?: StateEnum;
}

/**
 * Details about the role entity.
 * The provided fields are dependent on the entityType as provided.
 * User: userId, userHrn, realm, firstname, lastname, email, state
 * App: clientId, clientHrn, realm, name, description, ownerId, ownerHrn, defaultScope, isRestrictedScope, appCreationEnabled
 */
export interface RoleEntityInfo extends UserInfo {
    /**
     * Identifier for the client/application.
     */
    clientId?: string;
    /**
     * HRN for the client/application.
     */
    clientHrn?: string;
    /**
     * A realm to which app belongs to.
     */
    realm?: string;
    /**
     * Human readable name of the client.
     */
    name?: string;
    /**
     * Prose description of the client.
     */
    description?: string;
    /**
     * The id of the user that owns this client.
     */
    ownerId?: string;
    /**
     * The hrn of the user that owns this client.
     */
    ownerHrn?: string;
    /**
     * The default value for the "scope" parameter when requesting a client_credentials OAuth2 token
     * if no \"scope\" parameter is specified.
     */
    defaultScope?: string;
    /**
     * If true, the app cannot request a token with a scope different from defaultScope.
     */
    isRestrictedScope?: boolean;
    /**
     * If true, the app can create apps.
     */
    appCreationEnabled?: boolean;
}

/**
 * Details about the realm member.
 * The provided fields are dependent on the entityType as provided.
 * User: userId, userHrn, realm, firstname, lastname, email, roles, state
 * App: clientId, clientHrn, realm, name, description, roles, ownerId, ownerHrn, defaultScope, isRestrictedScope, appCreationEnabled
 */
export interface RealmMemberInfo extends UserInfo {
    /**
     * Identifier for the client/application.
     */
    clientId?: string;
    /**
     * HRN for the client/application.
     */
    clientHrn?: string;
    /**
     * A realm to which app belongs to.
     */
    realm?: string;
    /**
     * Human readable name of the client.
     */
    name?: string;
    /**
     * Prose description of the client.
     */
    description?: string;
    /**
     * The id of the user that owns this client.
     */
    ownerId?: string;
    /**
     * The hrn of the user that owns this client.
     */
    ownerHrn?: string;
    /**
     * The default value for the \"scope\" parameter when requesting a client_credentials OAuth2 token
     * if no \"scope\" parameter is specified.
     */
    defaultScope?: string;
    /**
     * If true, the app cannot request a token with a scope different from defaultScope.
     */
    isRestrictedScope?: boolean;
    /**
     * If true, the app can create apps.
     */
    appCreationEnabled?: boolean;
    /**
     * A list of roles assigned to the member. Each entry in the list will be equal to the 'name' of the role.
     */
    roles?: string[];
}

export type EntityTypeEnum = "user" | "app";

export interface RealmMember {
    memberHrn?: string;
    entityType?: EntityTypeEnum;
    info?: RealmMemberInfo;
}

export interface RealmMemberPageWToken extends PageWToken {
    data?: RealmMember[];
}

export interface RealmAuthorizationInvite {
    /**
     * The email address to send the invitation to.
     */
    emailAddress: string;
    /**
     * The first name of the invitee.
     */
    firstName?: string;
    /**
     * The last name of the invitee.
     */
    lastName?: string;
    /**
     * The group memberships to create for this invitation.
     */
    groupHrns?: string[];
}

export interface RealmAuthInviteResponse {
    /**
     * The hrn of the authorization invite.
     */
    hrn?: string;
    /**
     * The email address of the user.
     */
    emailAddress?: string;
    /**
     * The first name of the invitee.
     */
    firstName?: string;
    /**
     * The last name of the invitee.
     */
    lastName?: string;
    /**
     * The HRNs of the groups the invitee was added to during invite creation.
     */
    groupHrns?: string[];
    /**
     * The HRN of the entity that created the authorization.
     */
    creatorHrn?: string;
    /**
     * The HRN of the realm of the invitation.
     */
    realmHrn?: string;
    /**
     * Unix time (seconds) when the authorization was created.
     */
    createdTime?: string;
}

export interface ListInviteResponse {
    /**
     * The hrn of the authorization invite.
     */
    hrn?: string;
    /**
     * The email address of the user.
     */
    emailAddress?: string;
    /**
     * The first name of the invitee.
     */
    firstName?: string;
    /**
     * The last name of the invitee.
     */
    lastName?: string;
    /**
     * The HRN of the entity that created the authorization.
     */
    creatorHrn?: string;
    /**
     * The HRN of the realm of the invitation.
     */
    realmHrn?: string;
    /**
     * Unix time (seconds) when the authorization was created.
     */
    createdTime?: string;
}

export interface InvitePageWToken extends PageWToken {
    data?: ListInviteResponse[];
}

export interface EntityId {
    /**
     * The unique identifier of the user, app, or group.
     */
    id?: string;
    /**
     * The HRN of the user, app, or group.
     */
    hrn?: string;
    /**
     * The type of this entity. One of user, app, or group
     */
    type?: string;
}

export interface AppInfo {
    /**
     * Identifier for the client/application.
     */
    clientId?: string;
    /**
     * HRN for the client/application.
     */
    clientHrn?: string;
    /**
     * A realm to which app belongs to.
     */
    realm?: string;
    /**
     * Human readable name of the client.
     */
    name?: string;
    /**
     * Prose description of the client.
     */
    description?: string;
    /**
     * The id of the user that owns this client.
     */
    ownerId?: string;
    /**
     * The hrn of the user that owns this client.
     */
    ownerHrn?: string;
    /**
     * The default value for the "scope" parameter when requesting a client_credentials OAuth2 token if no "scope" parameter is specified.
     */
    defaultScope?: string;
    /**
     * If true, the app cannot request a token with a scope different from defaultScope.
     */
    isRestrictedScope?: boolean;
    /**
     * If true, the app can create apps.
     */
    appCreationEnabled?: boolean;
}

export interface GroupInfo {
    /**
     * The id of the group..
     */
    id?: string;
    /**
     * The hrn of the group..
     */
    hrn?: string;
    /**
     * A user assigned name for the group.
     */
    name?: string;
}

export interface ActivePermission {
    /**
     * The unique identifier of the permission in the context of the client.  Begins with \"PERM-\".
     */
    id?: string;
    /**
     * The specific action identifier that this permission is controlling access to for the specific associated service.
     */
    action?: string;
    /**
     * One of \"allow\" or \"deny\"
     */
    effect?: EffectEnum;
    /**
     * The resource identifier that this permission is controlling access to for the given action.
     */
    resource?: string;
    /**
     * Identifies the service that this permission is associated with.
     */
    serviceId?: string;
}

export type EffectEnum = "allow" | "deny";

export interface EntityGrant {
    entityId?: EntityId;
    user?: UserInfo;
    app?: AppInfo;
    group?: GroupInfo;
    /**
     * List of permissions
     */
    permissions?: ActivePermission[];
}

export interface EntityGrants {
    /**
     * Total entities
     */
    total?: number;
    /**
     * The pageToken used to retrieve the next page of entities
     */
    pageToken?: string;
    /**
     * count of page
     */
    count?: number;
    /**
     * List of users, apps, or groups and their associated permissions.
     */
    data?: EntityGrant[];
}

export interface Role {
    /**
     * Unique identifier for the role
     */
    id?: string;
    /**
     * Unique identifier for this role with partition/realm/etc, an HRN
     */
    hrn?: string;
    /**
     * System defined name for the role
     */
    name?: string;
    /**
     * Represents either Group or Realm HRN for which object is scoped for
     */
    resource?: string;
}

export interface RolePageWToken extends PageWToken {
    data?: Role[];
}

export interface RoleEntity {
    entityHrn?: string;
    entityType?: EntityTypeEnum;
    info?: RoleEntityInfo;
}
export interface RoleEntityPageWToken extends PageWToken {
    data?: RoleEntity[];
}

export interface PermissionPageWToken extends PageWToken {
    data?: ActivePermission[];
}
export interface GroupMember {
    memberHrn?: string;
    entityType?: EntityTypeEnum;
    info?: GroupMemberInfo;
}

export interface GroupMemberInfo extends UserInfo {
    /**
     * Identifier for the client/application.
     */
    clientId?: string;
    /**
     * HRN for the client/application.
     */
    clientHrn?: string;
    /**
     * The realm which the invite is associated with
     */
    realm?: string;
    /**
     * Human readable name of the client.
     */
    name?: string;
    /**
     * Prose description of the client.
     */
    description?: string;
    /**
     * The id of the user that owns this client.
     */
    ownerId?: string;
    /**
     * The hrn of the user that owns this client.
     */
    ownerHrn?: string;
    /**
     * The default value for the "scope" parameter when requesting a client_credentials OAuth2 token if no
     * "scope" parameter is specified.
     */
    defaultScope?: string;
    /**
     * If true, the app cannot request a token with a scope different from defaultScope.
     */
    isRestrictedScope?: boolean;
    /**
     * If true, the app can create apps.
     */
    appCreationEnabled?: boolean;
    /**
     * The unique identifier of the invite
     */
    inviteId?: string;
    /**
     * The HRN of the invite
     */
    inviteHrn?: string;
    /**
     * The first name of the user this invite is for.
     */
    firstname?: string;
    /**
     * The last name of the user this invite is for.
     */
    lastname?: string;
    /**
     * Email address of the user this invite is for.
     */
    email?: string;
}

export interface GroupMemberPageWToken extends PageWToken {
    data?: GroupMember[];
}

/**
 * Retrieve the groups a given entity is a member of. Restrictions:
 * The calling principal **must** have permission to take the **readGroups** action against the specified entity.
 *
 * @example: In order to retrieve the groups a user, HERE-4ba9aca3-fdf9-4cad-a3da-534494d6198f, is a member of,
 * a permission with the following would be required:
 * \"action\" : \"readGroups\"
 * \"resource\" : \"hrn:here:account::myrealm:user/HERE-4ba9aca3-fdf9-4cad-a3da-534494d6198f\"
 * This API works only with tokens that are not scoped to a project
 *
 * @summary Get entity group membership
 * @param realm HRN identifying the realm
 * @param member HRN identifying group or realm member
 * @param pageToken The cursor for pagination. Present only if there is an additional page of data to view.
 * @param count Number of records to return. Default is 100 records. Maximum is 100 records.
 */
export async function getEntityGroupMembership(
    builder: RequestBuilder,
    params: {
        realm: string;
        member: string;
        pageToken?: string;
        count?: number;
    }
): Promise<GroupPageWToken> {
    const baseUrl = "/realms/{realm}/members/{member}/groups"
        .replace("{realm}", UrlBuilder.toString(params["realm"]))
        .replace("{member}", UrlBuilder.toString(params["member"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("pageToken", params["pageToken"]);
    urlBuilder.appendQuery("count", params["count"]);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<GroupPageWToken>(urlBuilder, options);
}

/**
 * Retrieve the list of groups over which the provided entity has been granted the role of GroupAdmin.
 * Restrictions:
 * * The calling principal **must** have permission to take the **readGroups** action against
 * the specified entity.
 * @example: In order to retrieve the groups a user, HERE-4ba9aca3-fdf9-4cad-a3da-534494d6198f,
 * is an admin of, a permission with the following would be required:
 * * \"action\" : \"readGroups\"
 * * \"resource\" : \"hrn:here:account::myrealm:user/HERE-4ba9aca3-fdf9-4cad-a3da-534494d6198f\"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Get entity managed group
 * @param realm HRN identifying the realm
 * @param member HRN identifying group or realm member
 * @param count Number of records to return. Default is 100 records. Maximum is 100 records.
 * @param pageToken The cursor for pagination. Present only if there is an additional page of data to view.
 */
export async function getEntityManagedGroups(
    builder: RequestBuilder,
    params: {
        realm: string;
        member: string;
        count?: number;
        pageToken?: string;
    }
): Promise<GroupPageWToken> {
    const baseUrl = "/realms/{realm}/members/{member}/managedGroups"
        .replace("{realm}", UrlBuilder.toString(params["realm"]))
        .replace("{member}", UrlBuilder.toString(params["member"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("pageToken", params["pageToken"]);
    urlBuilder.appendQuery("count", params["count"]);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<GroupPageWToken>(urlBuilder, options);
}

/**
 * Retrieve the user or application details of the member defined by memberId. Restrictions:
 * * The calling principal **must** have permission to take the **readMembers** action against
 * the specified realm.
 * @example: In order to retrieve a member of the realm, _MyRealm_, a permission with the following
 * would be required:
 * * \"action\" : \"readMembers\"
 * * \"resource\" : \"hrn:here:account::myrealm:realm/myrealm\"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Get realm member
 * @param realm HRN identifying the realm
 * @param member HRN identifying group or realm member
 */
export async function getRealmMember(
    builder: RequestBuilder,
    params: { realm: string; member: string }
): Promise<RealmMember> {
    const baseUrl = "/realms/{realm}/members/{member}"
        .replace("{realm}", UrlBuilder.toString(params["realm"]))
        .replace("{member}", UrlBuilder.toString(params["member"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<RealmMember>(urlBuilder, options);
}

/**
 * Retrieve the list of members within the realm. Restrictions:
 * * The calling principal **must** have permission to take the **readMembers**
 * action against the specified realm.
 * @example: In order to list the members of the realm, _MyRealm_,
 * a permission with the following would be required:
 * * \"action\" : \"readMembers\"
 * * \"resource\" : \"hrn:here:account::myrealm:realm/myrealm\"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Get realm members
 * @param realm HRN identifying the realm
 * @param pageToken The cursor for pagination. Present only if there is an additional page of data to view.
 * @param count Number of records to return. Default is 100 records. Maximum is 100 records.
 * @param entityType The type of members to return in the result.
 * One of 'user' or 'app'.   If this parameter is omitted, all entity types will be returned.
 * @param q A free text query string used to filter the results.
 * A search against members in the realm will consider the
 * 'userId',
 * 'firstname',
 * 'lastname',
 * 'email',
 * 'clientId',
 * 'name' and 'roles' fields of the members.
 * The precise search algorithm used to match members is not specified,
 * but generally any member where one of the considered fields has a full or partial match should be included in the results.
 * @param state Only return user members with the given 'state' in the results.
 */
export async function getRealmMembers(
    builder: RequestBuilder,
    params: {
        realm: string;
        pageToken?: string;
        count?: number;
        entityType?: string;
        q?: string;
        state?: string;
    }
): Promise<RealmMemberPageWToken> {
    const baseUrl = "/realms/{realm}/members".replace(
        "{realm}",
        UrlBuilder.toString(params["realm"])
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("pageToken", params["pageToken"]);
    urlBuilder.appendQuery("count", params["count"]);
    urlBuilder.appendQuery("entityType", params["entityType"]);
    urlBuilder.appendQuery("q", params["q"]);
    urlBuilder.appendQuery("state", params["state"]);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<RealmMemberPageWToken>(urlBuilder, options);
}

/**
 * Cancel an invitation to the realm. Restrictions:
 * * The calling principal **must** have permission to take the **manageInvites**
 * action against the specified realm.
 * @example: In order to delete an invitation to the realm,
 * _MyRealm_, a permission with the following would be required:
 * * \"action\" : \"manageInvites\"
 * * \"resource\" : \"hrn:here:account::myrealm:realm/myrealm\"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Cancel a user invitation to a realm
 * @param realm HRN identifying the realm
 * @param invite HRN identifying a given invite.
 */
export async function cancelRealmMemberInvite(
    builder: RequestBuilder,
    params: { realm: string; invite: string }
): Promise<Response> {
    const baseUrl = "/realms/{realm}/invites/{invite}"
        .replace("{realm}", UrlBuilder.toString(params["realm"]))
        .replace("{invite}", UrlBuilder.toString(params["invite"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "DELETE",
        headers
    };

    return builder.requestBlob(urlBuilder, options);
}

/**
 * Create and send an invitation to add a new member to the realm,
 * optionally assign membership to one or more groups if the Inviter is also a **GroupAdmin**
 * for the group. Restrictions:
 * * The calling principal **must** have permission to take the
 * **manageInvites** action against the specified realm.
 * @example: In order to invite a new user to the realm, _MyRealm_,
 * a permission with the following would be required:
 * * \"action\" : \"manageInvites\"
 * * \"resource\" : \"hrn:here:account::myrealm:realm/myrealm\"
 * @example: In order to invite a new user to the realm, _MyRealm_,
 * as a member of the group GROUP-a3dee2fe-fb38-4183-b686-14fdea5964c0,
 * the following permissions would be required:
 * * \"action\" : \"manageInvites\"
 * * \"resource\" : \"hrn:here:account::myrealm:realm/myrealm\"
 * * \"action\" : \"manageMembers\"
 * * \"resource\" : \"hrn:here:authorization::myrealm:group/GROUP-a3dee2fe-fb38-4183-b686-14fdea5964c\"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Create and send a user invitation for a realm
 * @param body
 * @param realm HRN identifying the realm
 */
export async function createRealmMemberInvite(
    builder: RequestBuilder,
    params: { body: RealmAuthorizationInvite; realm: string }
): Promise<RealmAuthInviteResponse> {
    const baseUrl = "/realms/{realm}/invites".replace(
        "{realm}",
        UrlBuilder.toString(params["realm"])
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "POST",
        headers
    };
    headers["Content-Type"] = "application/json";
    if (params["body"] !== undefined) {
        options.body = JSON.stringify(params["body"]);
    }

    return builder.request<RealmAuthInviteResponse>(urlBuilder, options);
}

/**
 * Resend an invitation to a new member to the realm.
 * Restrictions:
 * * The calling principal **must** have permission to take the **manageInvites**
 * action against the specified realm.
 *
 * @example: In order to resend an invite to a new user to the realm, _MyRealm_,
 * a permission with the following would be required:
 * * \"action\" : \"manageInvites\"
 * * \"resource\" : \"hrn:here:account::myrealm:realm/myrealm\"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Resend an invitation to a user in a realm
 * @param realm HRN identifying the realm
 * @param invite HRN identifying a given invite.
 */
export async function resendRealmMemberInvite(
    builder: RequestBuilder,
    params: { realm: string; invite: string }
): Promise<Response> {
    const baseUrl = "/realms/{realm}/invites/{invite}"
        .replace("{realm}", UrlBuilder.toString(params["realm"]))
        .replace("{invite}", UrlBuilder.toString(params["invite"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "POST",
        headers
    };

    return builder.requestBlob(urlBuilder, options);
}

/**
 * Search for invitations in the realm, optionally providing a group.
 * Restrictions:
 * * The calling principal **must** have permission to take the **manageInvites**
 * action against the realm associated with the calling party.
 *
 * @example: In order to list the invitations within the calling party's realm a permission with the following would be required:
 * * \"action\" : \"manageInvites\"
 * * \"resource\" : \"hrn:here:account::myrealm:realm/myrealm\"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Search for invitations in a realm
 * @param realm HRN identifying the realm
 * @param group HRN idenitifying the group to search.
 * @param pageToken The cursor for pagination. Present only if there is an additional page of data to view.
 * @param count Number of records to return. Default is 100 records. Maximum is 100 records.
 * @param q A free text query string used to filter the results.
 * A search against invites in the realm will consider the 'firstName', 'lastName', and 'emailAddress' fields of the invites.
 * The precise search algorithm used to match invites is not specified, but generally any invite where one
 * of the considered fields has a full or partial match should be included in the results.
 */
export async function searchRealmMemberInvites(
    builder: RequestBuilder,
    params: {
        realm: string;
        group?: string;
        pageToken?: string;
        count?: number;
        q?: string;
    }
): Promise<InvitePageWToken> {
    const baseUrl = "/realms/{realm}/invites".replace(
        "{realm}",
        UrlBuilder.toString(params["realm"])
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("group", params["group"]);
    urlBuilder.appendQuery("pageToken", params["pageToken"]);
    urlBuilder.appendQuery("count", params["count"]);
    urlBuilder.appendQuery("q", params["q"]);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<InvitePageWToken>(urlBuilder, options);
}

/**
 * ===================================================================
 * GrantsApi
 * ===================================================================
 */

/**
 * Grant access to a resource to an entity.
 * The result of this call is that the specified entity will have permission to take the specified action against the specified resource.
 * Restrictions:
 * * The realm of the calling principal **must** match the realm of the requested entity.
 * * The calling principal **must** have permission to take the **addGrant:{actionId}** OR **share** action against the specified resource.
 * * Example: In order to add a grant for the **readResource** action against resource **hrn:here:data:::my-shared-catalog** a permission
 * with the following would be required:
 * * "action" : "addGrant:readResource"
 * * "resource" : "hrn:here:data:::my-shared-catalog"
 * OR
 * * "action" : "share"
 * * "resource" : "hrn:here:data:::my-shared-catalog"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Grant access to a resource to an entity.
 * @param resourceHrn The hrn that identifies the resource
 * @param entityId The target entityId to grant access to
 * @param actionId The action to assign as allowed against the resource
 * @param entityType The type of the entity to grant access to.  Must be one of user, app, or group
 */
export async function addGrant(
    builder: RequestBuilder,
    params: {
        resourceHrn: string;
        entityId: string;
        actionId: string;
        entityType: string;
    }
): Promise<EntityGrant> {
    const baseUrl = "/grants/resources/{resourceHrn}/entities/{entityId}/actions/{actionId}"
        .replace("{resourceHrn}", UrlBuilder.toString(params["resourceHrn"]))
        .replace("{entityId}", UrlBuilder.toString(params["entityId"]))
        .replace("{actionId}", UrlBuilder.toString(params["actionId"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("entityType", params["entityType"]);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "POST",
        headers
    };

    return builder.request<EntityGrant>(urlBuilder, options);
}

/**
 * Get a single grant given to an entity.
 * This calls returns any permission to take the specified action against the specified resource on the requested entity.
 * Restrictions:
 * * The realm of the calling principal **must** match the realm of the requested app.
 * * The calling principal **must** have permission to take the **listGrants** OR **share** action against the specified resource.
 * * In order to get a grant against resource **hrn:here:data:::my-shared-catalog**
 * a permission with the following would be required:
 * * "action" : "listGrants"
 * * "resource" : "hrn:here:data:::my-shared-catalog"
 * OR
 * * "action" : "share"
 * * "resource" : "hrn:here:data:::my-shared-catalog"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Get a single grant given to an entity
 * @param resourceHrn The hrn that identifies the resource
 * @param entityId The target entityId to get the grant of
 * @param actionId The action of the grant
 * @param entityType The type of the entity to get the grant of.  Must be one of user, app, or group
 */
export async function getGrant(
    builder: RequestBuilder,
    params: {
        resourceHrn: string;
        entityId: string;
        actionId: string;
        entityType: string;
    }
): Promise<EntityGrant> {
    const baseUrl = "/grants/resources/{resourceHrn}/entities/{entityId}/actions/{actionId}"
        .replace("{resourceHrn}", UrlBuilder.toString(params["resourceHrn"]))
        .replace("{entityId}", UrlBuilder.toString(params["entityId"]))
        .replace("{actionId}", UrlBuilder.toString(params["actionId"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("entityType", params["entityType"]);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<EntityGrant>(urlBuilder, options);
}

/**
 * Get grants. This call describes the permissions assigned to the specified entity that grant access to the specified resource.
 *
 * Restrictions:
 * * The realm of the calling principal **must** match the realm of the requested entity.
 * * The calling principal **must** have permission to take the **listGrants** OR **share** action against the specified resource.
 * * Example:
 * In order to get grants against resource **hrn:here:data:::my-shared-catalog** a permission with the following would be required:
 * * "action" : "listGrants"
 * * "resource" : "hrn:here:data:::my-shared-catalog"
 * OR
 * * "action" : "share"
 * * "resource" : "hrn:here:data:::my-shared-catalog"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Get grants given to a user, app, or group
 * @param resourceHrn The hrn that identifies the resource
 * @param entityId The entityId to get the grants of
 * @param entityType The type of the entity requested.  Must be one of user, app, or group
 */
export async function getGrants(
    builder: RequestBuilder,
    params: { resourceHrn: string; entityId: string; entityType: string }
): Promise<EntityGrant> {
    const baseUrl = "/grants/resources/{resourceHrn}/entities/{entityId}"
        .replace("{resourceHrn}", UrlBuilder.toString(params["resourceHrn"]))
        .replace("{entityId}", UrlBuilder.toString(params["entityId"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("entityType", params["entityType"]);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<EntityGrant>(urlBuilder, options);
}

/**
 * List grants on user, apps, or groups.
 * This call describes the permissions assigned to any user, app, or group **in the same realm as the calling principal**
 * that has been granted access to the specified resource through an exact matching permission.
 * Permissions granted through policies and roles are not included.
 * Restrictions:
 * * The calling principal **must** have permission to take the **listGrants** OR **share** action against the specified resource.
 * * Example:
 * In order to list grants against resource **hrn:here:data:::my-shared-catalog** a permission with the following would be required:
 * * "action" : "listGrants"
 * * "resource" : "hrn:here:data:::my-shared-catalog"
 * OR
 * * "action" : "share"
 * * "resource" : "hrn:here:data:::my-shared-catalog"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary List grants on users, apps, or groups
 * @param resourceHrn The hrn that identifies the resource
 * @param entityType Restrict to only this type of entity  in the response.  Must be one of user, app, or group
 * @param pageToken When there are more than 'count' total records, use the pageToken from the previous page to retrieve the next page
 * @param count Number of records to return
 */
export async function listGrants(
    builder: RequestBuilder,
    params: {
        resourceHrn: string;
        entityType?: string;
        pageToken?: string;
        count?: number;
    }
): Promise<EntityGrants> {
    const baseUrl = "/grants/resources/{resourceHrn}/entities".replace(
        "{resourceHrn}",
        UrlBuilder.toString(params["resourceHrn"])
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("entityType", params["entityType"]);
    urlBuilder.appendQuery("pageToken", params["pageToken"]);
    urlBuilder.appendQuery("count", params["count"]);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<EntityGrants>(urlBuilder, options);
}

/**
 * Revoke access to a resource from an entity.
 * The result of this call is that the specified entity will have any directly assigned permission
 * to take the specified action against the specified resource removed.
 *
 * Restrictions:
 * * The realm of the calling principal **must** match the realm of the requested app.
 * * The calling principal **must** have permission to take the **removeGrant:{actionId}**
 * OR **share** action against the specified resource.
 *
 * * Example: In order to remove a grant for the **readResource** action against resource **hrn:here:data:::my-shared-catalog**
 * a permission with the following would be required:
 * * "action" : "removeGrant:readResource"
 * * "resource" : "hrn:here:data:::my-shared-catalog"
 * OR
 * * "action" : "share"
 * * "resource" : "hrn:here:data:::my-shared-catalog"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Revoke access to a resource from an entity
 * @param resourceHrn The hrn that identifies the resource
 * @param entityId The target entityId to revoke access from
 * @param actionId The action against the resource to revoke access from
 * @param entityType The type of the entity to revoke access from.  Must be one of user, app, or group
 */
export async function removeGrant(
    builder: RequestBuilder,
    params: {
        resourceHrn: string;
        entityId: string;
        actionId: string;
        entityType: string;
    }
): Promise<Response> {
    const baseUrl = "/grants/resources/{resourceHrn}/entities/{entityId}/actions/{actionId}"
        .replace("{resourceHrn}", UrlBuilder.toString(params["resourceHrn"]))
        .replace("{entityId}", UrlBuilder.toString(params["entityId"]))
        .replace("{actionId}", UrlBuilder.toString(params["actionId"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("entityType", params["entityType"]);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "DELETE",
        headers
    };

    return builder.requestBlob(urlBuilder, options);
}

/**
 * ===================================================================
 * RolesApi
 * ===================================================================
 */

/**
 * Assign the role provided to the given entity.
 * If the provided role is associated with a group, the entity being assigned the role must be a member of the associated group.
 * Restrictions:
 * * The calling principal **must** have permission to take the **manageEntities** action against the specified role.
 * * Example: In order to assign the role, _GroupAdmin_, to an entity a permission with the following would
 * be required:
 * * "action" : "manageEntities"
 * * "resource" : "hrn:here:authorization::myrealm:role/ROLE-c1662138-a170-4264-ba18-7b506a708c37"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Assign a role to an entity
 * @param role HRN identifying a given role
 * @param entity HRN identifying a given entity
 */
export async function addRoleEntity(
    builder: RequestBuilder,
    params: { role: string; entity: string }
): Promise<Response> {
    const baseUrl = "/roles/{role}/entities/{entity}"
        .replace("{role}", UrlBuilder.toString(params["role"]))
        .replace("{entity}", UrlBuilder.toString(params["entity"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "POST",
        headers
    };

    return builder.requestBlob(urlBuilder, options);
}

/**
 * Remove the role provided to from the given member.
 * Restrictions:
 * * The calling principal **must** have permission to take the **manageEntities** action against the specified role.
 * * Example: In order to revoke the role, _GroupAdmin_, from an entity a permission with the following would be required:
 * * "action" : "manageEntities"
 * * "resource" : "hrn:here:authorization::myrealm:role/ROLE-c1662138-a170-4264-ba18-7b506a708c37"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Revoke a role from an entity
 * @param role HRN identifying a given role
 * @param entity HRN identifying a given entity
 */
export async function deleteRoleEntity(
    builder: RequestBuilder,
    params: { role: string; entity: string }
): Promise<Response> {
    const baseUrl = "/roles/{role}/entities/{entity}"
        .replace("{role}", UrlBuilder.toString(params["role"]))
        .replace("{entity}", UrlBuilder.toString(params["entity"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "DELETE",
        headers
    };

    return builder.requestBlob(urlBuilder, options);
}

/**
 * Retrieve the list of roles which have been assigned to the calling party.
 * This API works only with tokens that are not scoped to a project.
 *
 * @summary Get My Roles
 * @param pageToken The cursor for pagination. Present only if there is an additional page of data to view.
 * @param count Number of records to return. Default is 100 records. Maximum is 100 records.
 */
export async function getMyRoles(
    builder: RequestBuilder,
    params?: { pageToken?: string; count?: number }
): Promise<RolePageWToken> {
    const baseUrl = "/roles/me";

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    if (params) {
        urlBuilder.appendQuery("pageToken", params["pageToken"]);
        urlBuilder.appendQuery("count", params["count"]);
    }

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<RolePageWToken>(urlBuilder, options);
}

/**
 * Get the role identified by the provided Role HRN.
 *
 * Restrictions:
 * * The calling principal **must** have permission to take the **readRoles** action against the specified realm.
 *
 *  Example:
 * In order to retrieve a role within the realm, _MyRealm_, a permission with the following
 * would be required:
 * * "action" : "readRoles"
 * * "resource" : "hrn:here:account::myrealm:realm/myrealm"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Get Role
 * @param role HRN identifying a given role
 */
export async function getRole(
    builder: RequestBuilder,
    params: { role: string }
): Promise<Role> {
    const baseUrl = "/roles/{role}".replace(
        "{role}",
        UrlBuilder.toString(params["role"])
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<Role>(urlBuilder, options);
}

/**
 * Retrieve the list of entities which have been assigned the role as identified by the provided role HRN.
 *
 * Restrictions:
 * * The calling principal **must** have permission to take the **readEntities** action against the specified role.
 *
 * Example:
 * In order to list the entities assigned the role, _
 * hrn:here:authorization::myrealm:role/ROLE-c1662138-a170-4264-ba18-7b506a708c37_,
 * a permission with the following would be required:
 * * "action" : "readEntities"
 * * "resource" : "hrn:here:authorization::myrealm:role/ROLE-c1662138-a170-4264-ba18-7b506a708c37"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Get role entities
 * @param role HRN identifying a given role
 * @param pageToken The cursor for pagination. Present only if there is an additional page of data to view.
 * @param count Number of records to return. Default is 100 records. Maximum is 100 records.
 */
export async function getRoleEntities(
    builder: RequestBuilder,
    params: { role: string; pageToken?: string; count?: number }
): Promise<RoleEntityPageWToken> {
    const baseUrl = "/roles/{role}/entities".replace(
        "{role}",
        UrlBuilder.toString(params["role"])
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("pageToken", params["pageToken"]);
    urlBuilder.appendQuery("count", params["count"]);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<RoleEntityPageWToken>(urlBuilder, options);
}

/**
 * Retrieve a single entity which has been assigned the role as identified by the provided role HRN.
 *
 * Restrictions:
 * * The calling principal **must** have permission to take the **readEntities** action against the specified role.
 * * Example: In order to retrieve an entity assigned the role, _GroupAdmin_, a permission with the following
 * would be required:
 * * "action" : "readEntities"
 * * "resource" : "hrn:here:authorization::myrealm:role/ROLE-c1662138-a170-4264-ba18-7b506a708c37"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Get a single role entity
 * @param role HRN identifying a given role
 * @param entity HRN identifying a given entity
 */
export async function getRoleEntity(
    builder: RequestBuilder,
    params: { role: string; entity: string }
): Promise<RoleEntity> {
    const baseUrl = "/roles/{role}/entities/{entity}"
        .replace("{role}", UrlBuilder.toString(params["role"]))
        .replace("{entity}", UrlBuilder.toString(params["entity"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<RoleEntity>(urlBuilder, options);
}

/**
 * Get a single permission associated with the role identified by the provided Role HRN.
 *
 * Restrictions:
 * * The calling principal **must** have permission to take the **readPermissions** action against the specified role.
 * * Example: In order to retrieve a single role permission for the specified role in realm _MyRealm_,
 * a permission with the following would be required:
 * * "action" : "readPermissions"
 * * "resource" : "hrn:here:authorization::myrealm:role/ROLE-c1662138-a170-4264-ba18-7b506a708c37"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Get Role Permission
 * @param role HRN identifying a given role
 * @param permission Permission identifier
 */
export async function getRolePermission(
    builder: RequestBuilder,
    params: { role: string; permission: string }
): Promise<ActivePermission> {
    const baseUrl = "/roles/{role}/permissions/{permission}"
        .replace("{role}", UrlBuilder.toString(params["role"]))
        .replace("{permission}", UrlBuilder.toString(params["permission"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<ActivePermission>(urlBuilder, options);
}

/**
 * Get the permissions associated with the role identified by the provided Role HRN.
 *
 * Restrictions:
 * * The calling principal **must** have permission to take the **readPermissions** action against the specified role.
 *
 * Example:
 * In order to list role permissions for the specified role in realm _MyRealm_, a permission with the following
 * would be required:
 * * "action" : "readPermissions"
 * * "resource" : "hrn:here:authorization::myrealm:role/ROLE-c1662138-a170-4264-ba18-7b506a708c37"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Get Role Permissions
 * @param role HRN identifying a given role
 * @param pageToken The cursor for pagination. Present only if there is an additional page of data to view.
 * @param count Number of records to return. Default is 100 records. Maximum is 100 records.
 */
export async function getRolePermissions(
    builder: RequestBuilder,
    params: { role: string; pageToken?: string; count?: number }
): Promise<PermissionPageWToken> {
    const baseUrl = "/roles/{role}/permissions".replace(
        "{role}",
        UrlBuilder.toString(params["role"])
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("pageToken", params["pageToken"]);
    urlBuilder.appendQuery("count", params["count"]);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<PermissionPageWToken>(urlBuilder, options);
}

/**
 * Retrieve the list of roles within the context of the provided realm.
 *
 * Restrictions:
 * * The calling principal **must** have permission to take the **readRoles** action against the specified realm.
 * * Example: In order to list roles within the realm, _MyRealm_, a permission with the following would
 * be required:
 * * "action" : "readRoles"
 * * "resource" : "hrn:here:account::myrealm:realm/myrealm"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Get Roles
 * @param pageToken The cursor for pagination. Present only if there is an additional page of data to view.
 * @param count Number of records to return. Default is 100 records. Maximum is 100 records.
 * @param roleName The name of the role to be returned in the result set.
 * @param resource The hrn of the resource which the roles returned in the result set should be associated with.
 */
export async function getRoles(
    builder: RequestBuilder,
    params?: {
        pageToken?: string;
        count?: number;
        roleName?: string;
        resource?: string;
    }
): Promise<RolePageWToken> {
    const baseUrl = "/roles";

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    if (params) {
        urlBuilder.appendQuery("pageToken", params["pageToken"]);
        urlBuilder.appendQuery("count", params["count"]);
        urlBuilder.appendQuery("roleName", params["roleName"]);
        urlBuilder.appendQuery("resource", params["resource"]);
    }

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<RolePageWToken>(urlBuilder, options);
}

/**
 * ===================================================================
 * GroupsApi
 * ===================================================================
 */

/**
 * Add a single member to a group.
 *
 * Restrictions:
 * * The calling principal **must** have permission to take the **manageMembers** action against the group
 * identified by the provided group HRN.
 *
 * * Example:
 * In order to add a member to the group, _GROUP-8e270653-f592-45a8-88d7-46d409ccfa8a_, a permission with the following would
 * be required:
 * * \"action\" : \"manageMembers\"
 * * \"resource\" : \"hrn:here:authorization::myrealm:group/GROUP-8e270653-f592-45a8-88d7-46d409ccfa8a\"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Add a member to a group
 * @param groupId HRN identifying a group.
 * @param member HRN identifying group or realm member
 */
export async function addGroupMember(
    builder: RequestBuilder,
    params: { groupId: string; member: string }
): Promise<Response> {
    const baseUrl = "/groups/{groupId}/members/{member}"
        .replace("{groupId}", UrlBuilder.toString(params["groupId"]))
        .replace("{member}", UrlBuilder.toString(params["member"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "POST",
        headers
    };

    return builder.requestBlob(urlBuilder, options);
}

/**
 * Create a group within the realm that is associated with the calling party.
 * The calling party will be made a member and an administrator of the created group.
 *
 * Restrictions:
 * * The calling principal **must** have permission to take the **createGroup** action
 * against the realm associated with the calling party.
 *
 * * Example:
 * In order to create a group within the calling party's realm a permission with the following would be required:
 * * \"action\" : \"createGroup\"
 * * \"resource\" : \"hrn:here:account::myrealm:realm/myrealm\"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Create group
 * @param body
 */
export async function createGroup(
    builder: RequestBuilder,
    params: { body: Group }
): Promise<Group> {
    const baseUrl = "/groups";

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "POST",
        headers
    };
    headers["Content-Type"] = "application/json";
    if (params["body"] !== undefined) {
        options.body = JSON.stringify(params["body"]);
    }

    return builder.request<Group>(urlBuilder, options);
}

/**
 * Delete the group identified by the provided group HRN.
 *
 * Restrictions:
 * * The calling principal **must** have permission to take
 * the **deleteGroup** action against the group identified by the provided group HRN.
 *
 * * Example:
 * In order to delete the group, _GROUP-8e270653-f592-45a8-88d7-46d409ccfa8a_,
 * a permission with the following would be required:
 * * \"action\" : \"deleteGroup\"
 * * \"resource\" : \"hrn:here:authorization::myrealm:group/GROUP-8e270653-f592-45a8-88d7-46d409ccfa8a\"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary delete group
 * @param groupId HRN identifying a group.
 */
export async function deleteGroup(
    builder: RequestBuilder,
    params: { groupId: string }
): Promise<Response> {
    const baseUrl = "/groups/{groupId}".replace(
        "{groupId}",
        UrlBuilder.toString(params["groupId"])
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "DELETE",
        headers
    };

    return builder.requestBlob(urlBuilder, options);
}

/**
 * Retrieve the group identified by the provided group HRN.
 *
 * Restrictions:
 * * The calling principal **must** have permission to take the **readMembers** action
 * against the realm associated with the calling party.
 *
 * * Example:
 * In order to retrieve a group within the calling party's realm a permission
 * with the following would be required:
 * * \"action\" : \"readMembers\"
 * * \"resource\" : \"hrn:here:account::myrealm:realm/myrealm\"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Get single group
 * @param groupId HRN identifying a group.
 */
export async function getGroup(
    builder: RequestBuilder,
    params: { groupId: string }
): Promise<Group> {
    const baseUrl = "/groups/{groupId}".replace(
        "{groupId}",
        UrlBuilder.toString(params["groupId"])
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<Group>(urlBuilder, options);
}

/**
 * Retrieve a single group member.
 *
 * Restrictions:
 * * The calling principal **must** have permission to take the **readMembers** action against
 * the group identified by the provided group HRN.
 *
 * * Example:
 * In order to retrieve a single member of the group, _GROUP-8e270653-f592-45a8-88d7-46d409ccfa8a_,
 * a permission with the following would be required:
 * * \"action\" : \"readMembers\"
 * * \"resource\" : \"hrn:here:authorization::myrealm:group/GROUP-8e270653-f592-45a8-88d7-46d409ccfa8a\"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Get single Group member
 * @param groupId HRN identifying a group.
 * @param member HRN identifying group or realm member
 */
export async function getGroupMember(
    builder: RequestBuilder,
    params: { groupId: string; member: string }
): Promise<GroupMember> {
    const baseUrl = "/groups/{groupId}/members/{member}"
        .replace("{groupId}", UrlBuilder.toString(params["groupId"]))
        .replace("{member}", UrlBuilder.toString(params["member"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<GroupMember>(urlBuilder, options);
}

/**
 * Retrieve the list of members of the group identified by the provided group HRN.
 *
 * Restrictions:
 * * The calling principal **must** have permission to take the **readMembers** action against the group
 * identified by the provided group HRN.
 *
 * * Example: In order to retrieve the members of the group, _GROUP-8e270653-f592-45a8-88d7-46d409ccfa8a_,
 * a permission with the following would be required:
 * * \"action\" : \"readMembers\"
 * * \"resource\" : \"hrn:here:authorization::myrealm:group/GROUP-8e270653-f592-45a8-88d7-46d409ccfa8a\"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Get Group members
 * @param groupId HRN identifying a group.
 * @param pageToken The cursor for pagination. Present only if there is an additional page of data to view.
 * @param count Number of records to return. Default is 100 records. Maximum is 100 records.
 * @param entityType The type of members to return in the result.
 * One of 'user', 'app', or 'invite'.  If this parameter is omitted, all entity types will be returned.
 */
export async function getGroupMembers(
    builder: RequestBuilder,
    params: {
        groupId: string;
        pageToken?: string;
        count?: number;
        entityType?: string;
    }
): Promise<GroupMemberPageWToken> {
    const baseUrl = "/groups/{groupId}/members".replace(
        "{groupId}",
        UrlBuilder.toString(params["groupId"])
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("pageToken", params["pageToken"]);
    urlBuilder.appendQuery("count", params["count"]);
    urlBuilder.appendQuery("entityType", params["entityType"]);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<GroupMemberPageWToken>(urlBuilder, options);
}

/**
 * List the roles which are associated with the provided group.
 *
 * Restrictions:
 * * The calling principal **must** have permission to take the **readRoles** action against the specified group.
 * * Example: In order list the roles associated with the group, _GROUP-8e270653-f592-45a8-88d7-46d409ccfa8a_,
 * a permission with the following would be required:
 * * \"action\" : \"readRoles\"
 * * \"resource\" : \"hrn:here:authorization::myrealm:group/GROUP-8e270653-f592-45a8-88d7-46d409ccfa8a\"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Get group roles
 * @param groupId HRN identifying a group.
 * @param pageToken The cursor for pagination. Present only if there is an additional page of data to view.
 * @param count Number of records to return. Default is 100 records. Maximum is 100 records.
 */
export async function getGroupRoles(
    builder: RequestBuilder,
    params: { groupId: string; pageToken?: string; count?: number }
): Promise<RolePageWToken> {
    const baseUrl = "/groups/{groupId}/roles".replace(
        "{groupId}",
        UrlBuilder.toString(params["groupId"])
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("pageToken", params["pageToken"]);
    urlBuilder.appendQuery("count", params["count"]);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<RolePageWToken>(urlBuilder, options);
}

/**
 * Retrieve the list of groups within the realm associated with the calling party.
 *
 * Restrictions:
 * * The calling principal **must** have permission to take the **readMembers** action against the realm associated with the calling party.
 *
 * * Example:
 * In order to list the groups within the calling party's realm a permission with the following would be required:
 * * \"action\" : \"readMembers\"
 * * \"resource\" : \"hrn:here:account::myrealm:realm/myrealm\"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Get groups
 * @param pageToken The cursor for pagination. Present only if there is an additional page of data to view.
 * @param count Number of records to return. Default is 100 records. Maximum is 100 records.
 * @param q A free text query string used to filter the results.
 * A search against groups in the realm will consider the 'id', 'name', and 'description' fields of the groups.
 * The precise search algorithm used to match groups is not specified, but generally any member where
 * one of the considered fields has a full or partial match should be included in the results.
 */
export async function getGroups(
    builder: RequestBuilder,
    params?: { pageToken?: string; count?: number; q?: string }
): Promise<GroupPageWToken> {
    const baseUrl = "/groups";

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    if (params) {
        urlBuilder.appendQuery("pageToken", params["pageToken"]);
        urlBuilder.appendQuery("count", params["count"]);
        urlBuilder.appendQuery("q", params["q"]);
    }

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<GroupPageWToken>(urlBuilder, options);
}

/**
 * Retrieve a list of groups of a member
 *
 * This API works only with tokens that are not scoped to a project.
 *
 * @summary Get My Groups
 * @param pageToken The cursor for pagination. Present only if there is an additional page of data to view.
 * @param count Number of records to return. Default is 100 records. Maximum is 100 records.
 */
export async function getMyGroups(
    builder: RequestBuilder,
    params?: { pageToken?: string; count?: number }
): Promise<GroupPageWToken> {
    const baseUrl = "/groups/me";

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    if (params) {
        urlBuilder.appendQuery("pageToken", params["pageToken"]);
        urlBuilder.appendQuery("count", params["count"]);
    }

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<GroupPageWToken>(urlBuilder, options);
}

/**
 * Remove the calling party from the group. This operation will also remove administrative roles from this member.
 * This API works only with tokens that are not scoped to a project.
 *
 * @summary Removes the calling party from a group
 * @param groupId HRN identifying a group.
 */
export async function leaveGroup(
    builder: RequestBuilder,
    params: { groupId: string }
): Promise<Response> {
    const baseUrl = "/groups/{groupId}/members/me".replace(
        "{groupId}",
        UrlBuilder.toString(params["groupId"])
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "DELETE",
        headers
    };

    return builder.requestBlob(urlBuilder, options);
}

/**
 * Remove a member from the group. This operation will also remove administrative roles from this member.
 *
 * Restrictions:
 * * The calling principal **must** have permission to take the **manageMembers**
 * action against the group identified by the provided group HRN.
 *
 * * Example:
 * In order to remove a member from the group, _GROUP-8e270653-f592-45a8-88d7-46d409ccfa8a_,
 * a permission with the following would be required:
 * * \"action\" : \"manageMembers\"
 * * \"resource\" : \"hrn:here:authorization::myrealm:group/GROUP-8e270653-f592-45a8-88d7-46d409ccfa8a\"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Remove a member from the group.
 * @param groupId HRN identifying a group.
 * @param member HRN identifying group or realm member
 */
export async function removeGroupMember(
    builder: RequestBuilder,
    params: { groupId: string; member: string }
): Promise<Response> {
    const baseUrl = "/groups/{groupId}/members/{member}"
        .replace("{groupId}", UrlBuilder.toString(params["groupId"]))
        .replace("{member}", UrlBuilder.toString(params["member"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "DELETE",
        headers
    };

    return builder.requestBlob(urlBuilder, options);
}

/**
 * Update the group identified by the provided group HRN by updating all writable group fields including name and description.
 *
 * Restrictions:
 * * The calling principal **must** have permission to take the  **updateGroup** action
 * against the group identified by the provided group HRN.
 *
 * * Example:
 * In order to modify the group, _GROUP-8e270653-f592-45a8-88d7-46d409ccfa8a_, a permission with the following
 * would be required:
 * * \"action\" : \"updateGroup\"
 * * \"resource\" : \"hrn:here:authorization::myrealm:group/GROUP-8e270653-f592-45a8-88d7-46d409ccfa8a\"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Update group
 * @param body
 * @param groupId HRN identifying a group.
 */
export async function updateGroup(
    builder: RequestBuilder,
    params: { body: Group; groupId: string }
): Promise<Group> {
    const baseUrl = "/groups/{groupId}".replace(
        "{groupId}",
        UrlBuilder.toString(params["groupId"])
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "POST",
        headers
    };
    headers["Content-Type"] = "application/json";
    if (params["body"] !== undefined) {
        options.body = JSON.stringify(params["body"]);
    }

    return builder.request<Group>(urlBuilder, options);
}
