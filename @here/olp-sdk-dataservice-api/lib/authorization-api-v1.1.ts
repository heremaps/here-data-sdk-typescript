/*
 * Copyright (C) 2020 HERE Europe B.V. and its affiliate(s).
 * All rights reserved.
 *
 * This software and other materials contain proprietary information
 * controlled by HERE and are protected by applicable copyright legislation.
 * Any use and utilization of this software and other materials and
 * disclosure to any third parties is conditional upon having a separate
 * agreement with HERE for the access, use, utilization or disclosure of this
 * software. In the absence of such agreement, the use of the software is not
 * allowed.
 */

/**
 * Authorization API v1.1
 *   This specification is intended to describe the Authorization v1.1 APIs
 *
 *   OpenAPI spec version: 1.1.0
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 *
 * Do not edit the class manually.
 */

import { RequestBuilder, RequestOptions, UrlBuilder } from "./RequestBuilder";

export interface ProjectPolicyListResponse extends PageWithToken {
    /**
     * List of Project Policies
     */
    items?: ProjectPolicyResponse[];
}

export interface ProjectPolicyRequestBody {
    /**
     * The Identifier for the Project Policy.
     */
    id: string;
    /**
     * The name for the Project Policy
     */
    name: string;
    /**
     * The description for the Project Policy
     */
    description?: string;
    permissions: ProjectPolicyRequestBodyPermissions[];
}

export interface ProjectPolicyRequestBodyPermissions {
    /**
     * The hrn of the resource. One of resource or the resourceType must be defined
     */
    resource?: string;
    resourceType?: Type;
    /**
     * The list of actions allowed to be taken against either the resource
     * or the resource type defined in the Project Policy in the context of the Project
     */
    allowedActions: string[];
}

export interface ProjectPolicyResponse {
    /**
     * The Identifier for the Project Policy
     */
    id?: string;
    /**
     * The HRN for the Project Policy
     */
    hrn?: string;
    /**
     * The name for the Project Policy
     */
    name?: string;
    /**
     * The description for the Project Policy
     */
    description?: string;
    type?: "custom" | "here-platform";
    /**
     * The permissions that apply for the policy. Limited to a maximum of 100
     */
    permissions?: ProjectPolicyResponsePermissions[];
}

export interface ProjectPolicyResponsePermissions {
    /**
     * The hrn of the resource
     */
    resource?: string;
    resourceType?: Type;
    /**
     * The list of allowed actions for this Project Policy Permission
     */
    allowedActions?: string[];
}

export interface AttachedPolicy {
    /**
     * The hrn of the project policy Note - For HERE provided policies, the HRN format
     * would be - hrn:here:authorization::olp-here:here-platform:policy/read-only-access-to-all-catalogs
     */
    policy?: string;
}

export interface ResourceListWithPageToken extends PageWithTokenNoTotal {
    /**
     * List of Resources.
     */
    items?: ResourceResponse[];
}

export interface PageWithTokenNoTotal {
    /**
     * Maximum number of items to return.
     */
    limit: number;
    /**
     * The cursor for pagination. Present only if there is an additional page of data to view.
     */
    pageToken?: string;
}

export interface ResourceListDetailedWithPageToken
    extends PageWithTokenNoTotal {
    /**
     * List of Resources.
     */
    items?: ResourceResponseDetailed[];
}

export interface ResourceProjectResponse extends ProjectResponse {
    relation?: Relation;
    allowedActions?: AllowedActions;
}

export interface ResourceProjectListWithPageToken extends PageWithToken {
    /**
     * List of Projects associated with a given resource.
     */
    items?: ResourceProjectResponse[];
}

export interface ResourceResponse {
    /**
     * The hrn of the resource.
     */
    hrn?: string;
    type?: Type;
    /**
     * The hrn of the home project that the resource belongs to.
     */
    home?: string;
}

export interface ResourceResponseDetailed {
    /**
     * The hrn of the resource.
     */
    hrn?: string;
    type?: Type;
    /**
     * The hrn of the home project that the resource belongs to.
     */
    home?: string;
    relation?: Relation;
    allowedActions?: AllowedActions;
}

export interface LinkableResource {
    /**
     * The hrn of the resource.
     */
    resource?: string;
    /**
     * The hrn of the project that the resource is made linkable to.
     */
    projectHrn?: string;
    /**
     * The hrn of the project that the resource is made linkable to.
     */
    realmHrn?: string;
    allowedActions: AllowedActions;
}

export interface LinkableResourceList extends PageWithToken {
    /**
     * List of Projects.
     */
    items?: LinkableResource[];
}

export interface PatchProject {
    /**
     * The name of the Project.
     */
    name?: string;
    /**
     * The description of the Project.
     */
    description?: string;
}

export interface ResourceInProjectListWithPageToken extends PageWithToken {
    /**
     * List of Resources.
     */
    items?: ResourceInProjectResponse[];
}

export interface ResourceInProjectListWithPageToken extends PageWithToken {
    /**
     * List of Resources.
     */
    items?: ResourceInProjectResponse[];
}

export interface ProjectMemberListWithPageToken extends PageWithToken {
    /**
     * List of Project Members.
     */
    items?: ProjectMember[];
}

export interface ResourceInProjectResponse {
    /**
     * The hrn of the resource.
     */
    resource?: string;
    /**
     * The hrn of the project.
     */
    project?: string;
    type?: Type;
    relation?: Relation;
    allowedActions?: AllowedActions;
}

/**
 * The relation of the resource with the Project.
 */
export type Relation = "home" | "reference";

export interface ProjectMemberGroupInfo {
    /**
     * The id of the group.
     */
    groupId?: string;
    /**
     * The hrn of the group.
     */
    groupHrn?: string;
    /**
     * A user assigned name for the group.
     */
    name?: string;
}

export type IdentityTypeEnum = "user" | "app" | "group";
export interface ProjectMember {
    /**
     * The hrn of the Project.
     */
    project?: string;
    member?: string;
    identityType?: IdentityTypeEnum;
    /**
     * Details about the project member.
     *
     * The provided fields are dependent on the entity type.
     * User: userId, userHrn, realm, firstname, lastname, email, state.
     * App: clientId, clientHrn, realm, name, description, ownerId, ownerHrn, defaultScope, isRestrictedScope, appCreationEnabled.
     * Group: groupId, groupHrn, name.
     */
    info?: UserInfo & AppInfo & ProjectMemberGroupInfo;
}

export interface PageWithToken {
    /**
     * Maximum number of items to return.
     */
    limit: number;
    /**
     * The cursor for pagination. Present only if there is an additional page of data to view.
     */
    pageToken?: string;
    /**
     * Total number of items matching the search criteria.
     */
    total: number;
}

export interface ProjectListWithPageToken extends PageWithToken {
    /**
     * List of Projects.
     */
    items?: ProjectResponse[];
}

export interface ActivePermission {
    /**
     * The unique identifier of the permission in the context of the client.  Begins with "PERM-".
     */
    id?: string;
    /**
     * The specific action identifier that this permission is controlling access to for the specific associated service.
     */
    action?: string;
    /**
     * One of "allow" or "deny".
     */
    effect?: EffectEnum;
    /**
     * The resource identifier that this permission is controlling access to for the given action.
     */
    resource?: string;
    /**
     * Identifies the service that this permission is associated with.
     */
    serviceId?: string;
}

export interface ProjectResponse {
    /**
     * The id of the Project.
     */
    id?: string;
    /**
     * The hrn of the Project.
     */
    hrn?: string;
    /**
     * The name of the Project.
     */
    name?: string;
    /**
     * The description of the Project.
     */
    description?: string;
}

export interface ProjectRequest {
    /**
     * The id of the Project.
     */
    id: string;
    /**
     * The name of the Project.
     */
    name: string;
    /**
     * The description of the Project.
     */
    description?: string;
}

/**
 * The list of actions made available for referencing for the resourceType.
 *
 * These actions must be one of the "projectLinkingEnabled" actions of the service inferred via the reserved resource prefix of the
 * resource in the path.
 */
export interface AllowedActions extends Array<string> {}

/**
 * The type of the resource
 */
export type Type =
    | "catalog"
    | "pipeline"
    | "pipeline-template"
    | "schema"
    | "artifact"
    | "flow"
    | "flow-pattern";

/**
 * The relation of the resource with the Project
 */
export type ResourceRelation = "home" | "reference";

export interface ResourceRelationResponse {
    /**
     * The hrn of the resource.
     */
    resource?: string;
    /**
     * The hrn of the project.
     */
    project?: string;
    type?: Type;
    relation?: ResourceRelation;
    allowedActions?: AllowedActions;
}
export interface ResourceLinkActionBody {
    /**
     * The list of actions to add as a link to the project.
     * The actions must be one of the 'projectLinkingEnabled' action of the service and must be made linkable to the project or the realm.
     * via the '/resources/{resource}/linkable' API.
     */
    actions?: string[];
}
export interface PageWToken {
    /**
     * Total entities.
     */
    total?: number;

    /**
     * The pageToken used to retrieve the next page of entities.
     */
    pageToken?: string;

    /**
     * number of items returned.
     */
    count?: number;
}

export interface Group {
    id?: string;
    hrn?: string;

    /**
     * A user defined name for the group.
     * The following characters are not allowed in the group name: control characters, non-breaking space,
     * and * / < > \\  |.
     */
    name: string;

    realm?: string;

    /**
     * An optional user defined description for the group.
     * The following characters are not allowed in the group name: control characters, non-breaking space,
     * and * / < > \\  |.
     */
    description?: string;
}

export interface GroupPageWToken extends PageWToken {
    data: Group[];
}

export type StateEnum = "deleted" | "disabled" | "locked" | "enabled";

export interface UserInfo {
    /**
     * The unique identifier of the user.
     */
    userId?: string;
    /**
     * The HRN of the user.
     */
    userHrn?: string;
    /**
     * A realm which the user belongs to.
     */
    realm?: string;
    /**
     * The first name of the user. Only included if entityType is user.
     */
    firstname?: string;
    /**
     * The lastname of the user.  Only included if entityType is user.
     */
    lastname?: string;
    /**
     * Email address of the user.  Only included if entityType is user.
     */
    email?: string;
    /**
     * The status of this user.
     */
    state?: StateEnum;
}

/**
 * Details about the role entity.
 * The provided fields are dependent on the entityType as provided.
 * User: userId, userHrn, realm, firstname, lastname, email, state
 * App: clientId, clientHrn, realm, name, description, ownerId, ownerHrn, defaultScope, isRestrictedScope, appCreationEnabled
 */
export interface RoleEntityInfo extends UserInfo {
    /**
     * Identifier for the client/application.
     */
    clientId?: string;
    /**
     * HRN for the client/application.
     */
    clientHrn?: string;
    /**
     * A realm to which app belongs to.
     */
    realm?: string;
    /**
     * Human readable name of the client.
     */
    name?: string;
    /**
     * Prose description of the client.
     */
    description?: string;
    /**
     * The id of the user that owns this client.
     */
    ownerId?: string;
    /**
     * The hrn of the user that owns this client.
     */
    ownerHrn?: string;
    /**
     * The default value for the "scope" parameter when requesting a client_credentials OAuth2 token.
     * if no "scope" parameter is specified.
     */
    defaultScope?: string;
    /**
     * If true, the app cannot request a token with a scope different from defaultScope.
     */
    isRestrictedScope?: boolean;
    /**
     * If true, the app can create apps.
     */
    appCreationEnabled?: boolean;
}

/**
 * Details about the realm member.
 * The provided fields are dependent on the entityType as provided.
 * User: userId, userHrn, realm, firstname, lastname, email, roles, state.
 * App: clientId, clientHrn, realm, name, description, roles, ownerId, ownerHrn, defaultScope, isRestrictedScope, appCreationEnabled.
 */
export interface RealmMemberInfo extends UserInfo {
    /**
     * Identifier for the client/application.
     */
    clientId?: string;
    /**
     * HRN for the client/application.
     */
    clientHrn?: string;
    /**
     * A realm to which app belongs to.
     */
    realm?: string;
    /**
     * Human readable name of the client.
     */
    name?: string;
    /**
     * Prose description of the client.
     */
    description?: string;
    /**
     * The id of the user that owns this client.
     */
    ownerId?: string;
    /**
     * The hrn of the user that owns this client.
     */
    ownerHrn?: string;
    /**
     * The default value for the "scope" parameter when requesting a client_credentials OAuth2 token.
     * if no "scope" parameter is specified.
     */
    defaultScope?: string;
    /**
     * If true, the app cannot request a token with a scope different from defaultScope.
     */
    isRestrictedScope?: boolean;
    /**
     * If true, the app can create apps.
     */
    appCreationEnabled?: boolean;
    /**
     * A list of roles assigned to the member. Each entry in the list will be equal to the 'name' of the role.
     */
    roles?: string[];
}

export type EntityTypeEnum = "user" | "app";

export interface RealmMember {
    memberHrn?: string;
    entityType?: EntityTypeEnum;
    info?: RealmMemberInfo;
}

export interface RealmMemberPageWToken extends PageWToken {
    data?: RealmMember[];
}

export interface RealmAuthorizationInvite {
    /**
     * The email address to send the invitation to.
     */
    emailAddress: string;
    /**
     * The first name of the invitee.
     */
    firstName?: string;
    /**
     * The last name of the invitee.
     */
    lastName?: string;
    /**
     * The group memberships to create for this invitation.
     */
    groupHrns?: string[];
}

export interface RealmAuthInviteResponse {
    /**
     * The hrn of the authorization invite.
     */
    hrn?: string;
    /**
     * The email address of the user.
     */
    emailAddress?: string;
    /**
     * The first name of the invitee.
     */
    firstName?: string;
    /**
     * The last name of the invitee.
     */
    lastName?: string;
    /**
     * The HRNs of the groups the invitee was added to during invite creation.
     */
    groupHrns?: string[];
    /**
     * The HRN of the entity that created the authorization.
     */
    creatorHrn?: string;
    /**
     * The HRN of the realm of the invitation.
     */
    realmHrn?: string;
    /**
     * Unix time (seconds) when the authorization was created.
     */
    createdTime?: string;
}

export interface ListInviteResponse {
    /**
     * The hrn of the authorization invite.
     */
    hrn?: string;
    /**
     * The email address of the user.
     */
    emailAddress?: string;
    /**
     * The first name of the invitee.
     */
    firstName?: string;
    /**
     * The last name of the invitee.
     */
    lastName?: string;
    /**
     * The HRN of the entity that created the authorization.
     */
    creatorHrn?: string;
    /**
     * The HRN of the realm of the invitation.
     */
    realmHrn?: string;
    /**
     * Unix time (seconds) when the authorization was created.
     */
    createdTime?: string;
}

export interface InvitePageWToken extends PageWToken {
    data?: ListInviteResponse[];
}

export interface EntityId {
    /**
     * The unique identifier of the user, app, or group.
     */
    id?: string;
    /**
     * The HRN of the user, app, or group.
     */
    hrn?: string;
    /**
     * The type of this entity. One of user, app, or group.
     */
    type?: string;
}

export interface AppInfo {
    /**
     * Identifier for the client/application.
     */
    clientId?: string;
    /**
     * HRN for the client/application.
     */
    clientHrn?: string;
    /**
     * A realm to which app belongs to.
     */
    realm?: string;
    /**
     * Human readable name of the client.
     */
    name?: string;
    /**
     * Prose description of the client.
     */
    description?: string;
    /**
     * The id of the user that owns this client.
     */
    ownerId?: string;
    /**
     * The hrn of the user that owns this client.
     */
    ownerHrn?: string;
    /**
     * The default value for the "scope" parameter when requesting a client_credentials OAuth2 token if no "scope" parameter is specified.
     */
    defaultScope?: string;
    /**
     * If true, the app cannot request a token with a scope different from defaultScope.
     */
    isRestrictedScope?: boolean;
    /**
     * If true, the app can create apps.
     */
    appCreationEnabled?: boolean;
}

export interface GroupInfo {
    /**
     * The id of the group.
     */
    id?: string;
    /**
     * The hrn of the group.
     */
    hrn?: string;
    /**
     * A user assigned name for the group.
     */
    name?: string;
}

export interface ActivePermission {
    /**
     * The unique identifier of the permission in the context of the client.  Begins with "PERM-".
     */
    id?: string;
    /**
     * The specific action identifier that this permission is controlling access to for the specific associated service.
     */
    action?: string;
    /**
     * One of "allow" or "deny".
     */
    effect?: EffectEnum;
    /**
     * The resource identifier that this permission is controlling access to for the given action.
     */
    resource?: string;
    /**
     * Identifies the service that this permission is associated with.
     */
    serviceId?: string;
}

export type EffectEnum = "allow" | "deny";

export interface EntityGrant {
    entityId?: EntityId;
    user?: UserInfo;
    app?: AppInfo;
    group?: GroupInfo;
    /**
     * List of permissions.
     */
    permissions?: ActivePermission[];
}

export interface EntityGrants {
    /**
     * Total entities.
     */
    total?: number;
    /**
     * The pageToken used to retrieve the next page of entities.
     */
    pageToken?: string;
    /**
     * count of page.
     */
    count?: number;
    /**
     * List of users, apps, or groups and their associated permissions.
     */
    data?: EntityGrant[];
}

export interface Role {
    /**
     * Unique identifier for the role.
     */
    id?: string;
    /**
     * Unique identifier for this role with partition/realm/etc, an HRN.
     */
    hrn?: string;
    /**
     * System defined name for the role.
     */
    name?: string;
    /**
     * Represents either Group or Realm HRN for which object is scoped for.
     */
    resource?: string;
}

export interface RolePageWToken extends PageWToken {
    data?: Role[];
}

export interface RoleEntity {
    entityHrn?: string;
    entityType?: EntityTypeEnum;
    info?: RoleEntityInfo;
}
export interface RoleEntityPageWToken extends PageWToken {
    data?: RoleEntity[];
}

export interface PermissionPageWToken extends PageWToken {
    data?: ActivePermission[];
}
export interface GroupMember {
    memberHrn?: string;
    entityType?: EntityTypeEnum;
    info?: GroupMemberInfo;
}

export interface GroupMemberInfo extends UserInfo {
    /**
     * Identifier for the client/application.
     */
    clientId?: string;
    /**
     * HRN for the client/application.
     */
    clientHrn?: string;
    /**
     * The realm which the invite is associated with.
     */
    realm?: string;
    /**
     * Human readable name of the client.
     */
    name?: string;
    /**
     * Prose description of the client.
     */
    description?: string;
    /**
     * The id of the user that owns this client.
     */
    ownerId?: string;
    /**
     * The hrn of the user that owns this client.
     */
    ownerHrn?: string;
    /**
     * The default value for the "scope" parameter when requesting a client_credentials OAuth2 token if no.
     * "scope" parameter is specified.
     */
    defaultScope?: string;
    /**
     * If true, the app cannot request a token with a scope different from defaultScope.
     */
    isRestrictedScope?: boolean;
    /**
     * If true, the app can create apps.
     */
    appCreationEnabled?: boolean;
    /**
     * The unique identifier of the invite.
     */
    inviteId?: string;
    /**
     * The HRN of the invite.
     */
    inviteHrn?: string;
    /**
     * The first name of the user this invite is for.
     */
    firstname?: string;
    /**
     * The last name of the user this invite is for.
     */
    lastname?: string;
    /**
     * Email address of the user this invite is for.
     */
    email?: string;
}

export interface GroupMemberPageWToken extends PageWToken {
    data?: GroupMember[];
}

/**
 * Retrieve the groups a given entity is a member of. Restrictions:
 * The calling principal **must** have permission to take the **readGroups** action against the specified entity.
 *
 * @example: In order to retrieve the groups a user, HERE-4ba9aca3-fdf9-4cad-a3da-534494d6198f, is a member of,
 * a permission with the following would be required:
 * "action" : "readGroups"
 * "resource" : "hrn:here:account::myrealm:user/HERE-4ba9aca3-fdf9-4cad-a3da-534494d6198f"
 * This API works only with tokens that are not scoped to a project
 *
 * @summary Get entity group membership
 * @param realm HRN identifying the realm
 * @param member HRN identifying group or realm member
 * @param pageToken The cursor for pagination. Present only if there is an additional page of data to view.
 * @param count Number of records to return. Default is 100 records. Maximum is 100 records.
 */
export async function getEntityGroupMembership(
    builder: RequestBuilder,
    params: {
        realm: string;
        member: string;
        pageToken?: string;
        count?: number;
    }
): Promise<GroupPageWToken> {
    const baseUrl = "/realms/{realm}/members/{member}/groups"
        .replace("{realm}", UrlBuilder.toString(params["realm"]))
        .replace("{member}", UrlBuilder.toString(params["member"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("pageToken", params["pageToken"]);
    urlBuilder.appendQuery("count", params["count"]);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<GroupPageWToken>(urlBuilder, options);
}

/**
 * Retrieve the list of groups over which the provided entity has been granted the role of GroupAdmin.
 * Restrictions:
 * * The calling principal **must** have permission to take the **readGroups** action against
 * the specified entity.
 * @example: In order to retrieve the groups a user, HERE-4ba9aca3-fdf9-4cad-a3da-534494d6198f,
 * is an admin of, a permission with the following would be required:
 * * "action" : "readGroups"
 * * "resource" : "hrn:here:account::myrealm:user/HERE-4ba9aca3-fdf9-4cad-a3da-534494d6198f"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Get entity managed group
 * @param realm HRN identifying the realm
 * @param member HRN identifying group or realm member
 * @param count Number of records to return. Default is 100 records. Maximum is 100 records.
 * @param pageToken The cursor for pagination. Present only if there is an additional page of data to view.
 */
export async function getEntityManagedGroups(
    builder: RequestBuilder,
    params: {
        realm: string;
        member: string;
        count?: number;
        pageToken?: string;
    }
): Promise<GroupPageWToken> {
    const baseUrl = "/realms/{realm}/members/{member}/managedGroups"
        .replace("{realm}", UrlBuilder.toString(params["realm"]))
        .replace("{member}", UrlBuilder.toString(params["member"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("pageToken", params["pageToken"]);
    urlBuilder.appendQuery("count", params["count"]);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<GroupPageWToken>(urlBuilder, options);
}

/**
 * Retrieve the user or application details of the member defined by memberId. Restrictions:
 * * The calling principal **must** have permission to take the **readMembers** action against
 * the specified realm.
 * @example: In order to retrieve a member of the realm, _MyRealm_, a permission with the following
 * would be required:
 * * "action" : "readMembers"
 * * "resource" : "hrn:here:account::myrealm:realm/myrealm"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Get realm member
 * @param realm HRN identifying the realm
 * @param member HRN identifying group or realm member
 */
export async function getRealmMember(
    builder: RequestBuilder,
    params: { realm: string; member: string }
): Promise<RealmMember> {
    const baseUrl = "/realms/{realm}/members/{member}"
        .replace("{realm}", UrlBuilder.toString(params["realm"]))
        .replace("{member}", UrlBuilder.toString(params["member"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<RealmMember>(urlBuilder, options);
}

/**
 * Retrieve the list of members within the realm. Restrictions:
 * * The calling principal **must** have permission to take the **readMembers**
 * action against the specified realm.
 * @example: In order to list the members of the realm, _MyRealm_,
 * a permission with the following would be required:
 * * "action" : "readMembers"
 * * "resource" : "hrn:here:account::myrealm:realm/myrealm"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Get realm members
 * @param realm HRN identifying the realm
 * @param pageToken The cursor for pagination. Present only if there is an additional page of data to view.
 * @param count Number of records to return. Default is 100 records. Maximum is 100 records.
 * @param entityType The type of members to return in the result.
 * One of 'user' or 'app'.   If this parameter is omitted, all entity types will be returned.
 * @param q A free text query string used to filter the results.
 * A search against members in the realm will consider the
 * 'userId',
 * 'firstname',
 * 'lastname',
 * 'email',
 * 'clientId',
 * 'name' and 'roles' fields of the members.
 * The precise search algorithm used to match members is not specified,
 * but generally any member where one of the considered fields has a full or partial match should be included in the results.
 * @param state Only return user members with the given 'state' in the results.
 */
export async function getRealmMembers(
    builder: RequestBuilder,
    params: {
        realm: string;
        pageToken?: string;
        count?: number;
        entityType?: string;
        q?: string;
        state?: string;
    }
): Promise<RealmMemberPageWToken> {
    const baseUrl = "/realms/{realm}/members".replace(
        "{realm}",
        UrlBuilder.toString(params["realm"])
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("pageToken", params["pageToken"]);
    urlBuilder.appendQuery("count", params["count"]);
    urlBuilder.appendQuery("entityType", params["entityType"]);
    urlBuilder.appendQuery("q", params["q"]);
    urlBuilder.appendQuery("state", params["state"]);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<RealmMemberPageWToken>(urlBuilder, options);
}

/**
 * Cancel an invitation to the realm. Restrictions:
 * * The calling principal **must** have permission to take the **manageInvites**
 * action against the specified realm.
 * @example: In order to delete an invitation to the realm,
 * _MyRealm_, a permission with the following would be required:
 * * "action" : "manageInvites"
 * * "resource" : "hrn:here:account::myrealm:realm/myrealm"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Cancel a user invitation to a realm
 * @param realm HRN identifying the realm
 * @param invite HRN identifying a given invite.
 */
export async function cancelRealmMemberInvite(
    builder: RequestBuilder,
    params: { realm: string; invite: string }
): Promise<Response> {
    const baseUrl = "/realms/{realm}/invites/{invite}"
        .replace("{realm}", UrlBuilder.toString(params["realm"]))
        .replace("{invite}", UrlBuilder.toString(params["invite"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "DELETE",
        headers
    };

    return builder.requestBlob(urlBuilder, options);
}

/**
 * Create and send an invitation to add a new member to the realm,
 * optionally assign membership to one or more groups if the Inviter is also a **GroupAdmin**
 * for the group. Restrictions:
 * * The calling principal **must** have permission to take the
 * **manageInvites** action against the specified realm.
 * @example: In order to invite a new user to the realm, _MyRealm_,
 * a permission with the following would be required:
 * * "action" : "manageInvites"
 * * "resource" : "hrn:here:account::myrealm:realm/myrealm"
 * @example: In order to invite a new user to the realm, _MyRealm_,
 * as a member of the group GROUP-a3dee2fe-fb38-4183-b686-14fdea5964c0,
 * the following permissions would be required:
 * * "action" : "manageInvites"
 * * "resource" : "hrn:here:account::myrealm:realm/myrealm"
 * * "action" : "manageMembers"
 * * "resource" : "hrn:here:authorization::myrealm:group/GROUP-a3dee2fe-fb38-4183-b686-14fdea5964c"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Create and send a user invitation for a realm
 * @param body
 * @param realm HRN identifying the realm
 */
export async function createRealmMemberInvite(
    builder: RequestBuilder,
    params: { body: RealmAuthorizationInvite; realm: string }
): Promise<RealmAuthInviteResponse> {
    const baseUrl = "/realms/{realm}/invites".replace(
        "{realm}",
        UrlBuilder.toString(params["realm"])
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "POST",
        headers
    };
    headers["Content-Type"] = "application/json";
    if (params["body"] !== undefined) {
        options.body = JSON.stringify(params["body"]);
    }

    return builder.request<RealmAuthInviteResponse>(urlBuilder, options);
}

/**
 * Resend an invitation to a new member to the realm.
 * Restrictions:
 * * The calling principal **must** have permission to take the **manageInvites**
 * action against the specified realm.
 *
 * @example: In order to resend an invite to a new user to the realm, _MyRealm_,
 * a permission with the following would be required:
 * * "action" : "manageInvites"
 * * "resource" : "hrn:here:account::myrealm:realm/myrealm"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Resend an invitation to a user in a realm
 * @param realm HRN identifying the realm
 * @param invite HRN identifying a given invite.
 */
export async function resendRealmMemberInvite(
    builder: RequestBuilder,
    params: { realm: string; invite: string }
): Promise<Response> {
    const baseUrl = "/realms/{realm}/invites/{invite}"
        .replace("{realm}", UrlBuilder.toString(params["realm"]))
        .replace("{invite}", UrlBuilder.toString(params["invite"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "POST",
        headers
    };

    return builder.requestBlob(urlBuilder, options);
}

/**
 * Search for invitations in the realm, optionally providing a group.
 * Restrictions:
 * * The calling principal **must** have permission to take the **manageInvites**
 * action against the realm associated with the calling party.
 *
 * @example: In order to list the invitations within the calling party's realm a permission with the following would be required:
 * * "action" : "manageInvites"
 * * "resource" : "hrn:here:account::myrealm:realm/myrealm"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Search for invitations in a realm
 * @param realm HRN identifying the realm
 * @param group HRN idenitifying the group to search.
 * @param pageToken The cursor for pagination. Present only if there is an additional page of data to view.
 * @param count Number of records to return. Default is 100 records. Maximum is 100 records.
 * @param q A free text query string used to filter the results.
 * A search against invites in the realm will consider the 'firstName', 'lastName', and 'emailAddress' fields of the invites.
 * The precise search algorithm used to match invites is not specified, but generally any invite where one
 * of the considered fields has a full or partial match should be included in the results.
 */
export async function searchRealmMemberInvites(
    builder: RequestBuilder,
    params: {
        realm: string;
        group?: string;
        pageToken?: string;
        count?: number;
        q?: string;
    }
): Promise<InvitePageWToken> {
    const baseUrl = "/realms/{realm}/invites".replace(
        "{realm}",
        UrlBuilder.toString(params["realm"])
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("group", params["group"]);
    urlBuilder.appendQuery("pageToken", params["pageToken"]);
    urlBuilder.appendQuery("count", params["count"]);
    urlBuilder.appendQuery("q", params["q"]);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<InvitePageWToken>(urlBuilder, options);
}

/**
 * ===================================================================
 * GrantsApi
 * ===================================================================
 */

/**
 * Grant access to a resource to an entity.
 * The result of this call is that the specified entity will have permission to take the specified action against the specified resource.
 * Restrictions:
 * * The realm of the calling principal **must** match the realm of the requested entity.
 * * The calling principal **must** have permission to take the **addGrant:{actionId}** OR **share** action against the specified resource.
 * * Example: In order to add a grant for the **readResource** action against resource **hrn:here:data:::my-shared-catalog** a permission
 * with the following would be required:
 * * "action" : "addGrant:readResource"
 * * "resource" : "hrn:here:data:::my-shared-catalog"
 * OR
 * * "action" : "share"
 * * "resource" : "hrn:here:data:::my-shared-catalog"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Grant access to a resource to an entity.
 * @param resourceHrn The hrn that identifies the resource
 * @param entityId The target entityId to grant access to
 * @param actionId The action to assign as allowed against the resource
 * @param entityType The type of the entity to grant access to.  Must be one of user, app, or group
 */
export async function addGrant(
    builder: RequestBuilder,
    params: {
        resourceHrn: string;
        entityId: string;
        actionId: string;
        entityType: string;
    }
): Promise<EntityGrant> {
    const baseUrl = "/grants/resources/{resourceHrn}/entities/{entityId}/actions/{actionId}"
        .replace("{resourceHrn}", UrlBuilder.toString(params["resourceHrn"]))
        .replace("{entityId}", UrlBuilder.toString(params["entityId"]))
        .replace("{actionId}", UrlBuilder.toString(params["actionId"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("entityType", params["entityType"]);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "POST",
        headers
    };

    return builder.request<EntityGrant>(urlBuilder, options);
}

/**
 * Get a single grant given to an entity.
 * This calls returns any permission to take the specified action against the specified resource on the requested entity.
 * Restrictions:
 * * The realm of the calling principal **must** match the realm of the requested app.
 * * The calling principal **must** have permission to take the **listGrants** OR **share** action against the specified resource.
 * * In order to get a grant against resource **hrn:here:data:::my-shared-catalog**
 * a permission with the following would be required:
 * * "action" : "listGrants"
 * * "resource" : "hrn:here:data:::my-shared-catalog"
 * OR
 * * "action" : "share"
 * * "resource" : "hrn:here:data:::my-shared-catalog"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Get a single grant given to an entity
 * @param resourceHrn The hrn that identifies the resource
 * @param entityId The target entityId to get the grant of
 * @param actionId The action of the grant
 * @param entityType The type of the entity to get the grant of.  Must be one of user, app, or group
 */
export async function getGrant(
    builder: RequestBuilder,
    params: {
        resourceHrn: string;
        entityId: string;
        actionId: string;
        entityType: string;
    }
): Promise<EntityGrant> {
    const baseUrl = "/grants/resources/{resourceHrn}/entities/{entityId}/actions/{actionId}"
        .replace("{resourceHrn}", UrlBuilder.toString(params["resourceHrn"]))
        .replace("{entityId}", UrlBuilder.toString(params["entityId"]))
        .replace("{actionId}", UrlBuilder.toString(params["actionId"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("entityType", params["entityType"]);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<EntityGrant>(urlBuilder, options);
}

/**
 * Get grants. This call describes the permissions assigned to the specified entity that grant access to the specified resource.
 *
 * Restrictions:
 * * The realm of the calling principal **must** match the realm of the requested entity.
 * * The calling principal **must** have permission to take the **listGrants** OR **share** action against the specified resource.
 * * Example:
 * In order to get grants against resource **hrn:here:data:::my-shared-catalog** a permission with the following would be required:
 * * "action" : "listGrants"
 * * "resource" : "hrn:here:data:::my-shared-catalog"
 * OR
 * * "action" : "share"
 * * "resource" : "hrn:here:data:::my-shared-catalog"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Get grants given to a user, app, or group
 * @param resourceHrn The hrn that identifies the resource
 * @param entityId The entityId to get the grants of
 * @param entityType The type of the entity requested.  Must be one of user, app, or group
 */
export async function getGrants(
    builder: RequestBuilder,
    params: { resourceHrn: string; entityId: string; entityType: string }
): Promise<EntityGrant> {
    const baseUrl = "/grants/resources/{resourceHrn}/entities/{entityId}"
        .replace("{resourceHrn}", UrlBuilder.toString(params["resourceHrn"]))
        .replace("{entityId}", UrlBuilder.toString(params["entityId"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("entityType", params["entityType"]);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<EntityGrant>(urlBuilder, options);
}

/**
 * List grants on user, apps, or groups.
 * This call describes the permissions assigned to any user, app, or group **in the same realm as the calling principal**
 * that has been granted access to the specified resource through an exact matching permission.
 * Permissions granted through policies and roles are not included.
 * Restrictions:
 * * The calling principal **must** have permission to take the **listGrants** OR **share** action against the specified resource.
 * * Example:
 * In order to list grants against resource **hrn:here:data:::my-shared-catalog** a permission with the following would be required:
 * * "action" : "listGrants"
 * * "resource" : "hrn:here:data:::my-shared-catalog"
 * OR
 * * "action" : "share"
 * * "resource" : "hrn:here:data:::my-shared-catalog"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary List grants on users, apps, or groups
 * @param resourceHrn The hrn that identifies the resource
 * @param entityType Restrict to only this type of entity  in the response.  Must be one of user, app, or group
 * @param pageToken When there are more than 'count' total records, use the pageToken from the previous page to retrieve the next page
 * @param count Number of records to return
 */
export async function listGrants(
    builder: RequestBuilder,
    params: {
        resourceHrn: string;
        entityType?: string;
        pageToken?: string;
        count?: number;
    }
): Promise<EntityGrants> {
    const baseUrl = "/grants/resources/{resourceHrn}/entities".replace(
        "{resourceHrn}",
        UrlBuilder.toString(params["resourceHrn"])
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("entityType", params["entityType"]);
    urlBuilder.appendQuery("pageToken", params["pageToken"]);
    urlBuilder.appendQuery("count", params["count"]);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<EntityGrants>(urlBuilder, options);
}

/**
 * Revoke access to a resource from an entity.
 * The result of this call is that the specified entity will have any directly assigned permission
 * to take the specified action against the specified resource removed.
 *
 * Restrictions:
 * * The realm of the calling principal **must** match the realm of the requested app.
 * * The calling principal **must** have permission to take the **removeGrant:{actionId}**
 * OR **share** action against the specified resource.
 *
 * * Example: In order to remove a grant for the **readResource** action against resource **hrn:here:data:::my-shared-catalog**
 * a permission with the following would be required:
 * * "action" : "removeGrant:readResource"
 * * "resource" : "hrn:here:data:::my-shared-catalog"
 * OR
 * * "action" : "share"
 * * "resource" : "hrn:here:data:::my-shared-catalog"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Revoke access to a resource from an entity
 * @param resourceHrn The hrn that identifies the resource
 * @param entityId The target entityId to revoke access from
 * @param actionId The action against the resource to revoke access from
 * @param entityType The type of the entity to revoke access from.  Must be one of user, app, or group
 */
export async function removeGrant(
    builder: RequestBuilder,
    params: {
        resourceHrn: string;
        entityId: string;
        actionId: string;
        entityType: string;
    }
): Promise<Response> {
    const baseUrl = "/grants/resources/{resourceHrn}/entities/{entityId}/actions/{actionId}"
        .replace("{resourceHrn}", UrlBuilder.toString(params["resourceHrn"]))
        .replace("{entityId}", UrlBuilder.toString(params["entityId"]))
        .replace("{actionId}", UrlBuilder.toString(params["actionId"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("entityType", params["entityType"]);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "DELETE",
        headers
    };

    return builder.requestBlob(urlBuilder, options);
}

/**
 * ===================================================================
 * RolesApi
 * ===================================================================
 */

/**
 * Assign the role provided to the given entity.
 * If the provided role is associated with a group, the entity being assigned the role must be a member of the associated group.
 * Restrictions:
 * * The calling principal **must** have permission to take the **manageEntities** action against the specified role.
 * * Example: In order to assign the role, _GroupAdmin_, to an entity a permission with the following would
 * be required:
 * * "action" : "manageEntities"
 * * "resource" : "hrn:here:authorization::myrealm:role/ROLE-c1662138-a170-4264-ba18-7b506a708c37"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Assign a role to an entity
 * @param role HRN identifying a given role
 * @param entity HRN identifying a given entity
 */
export async function addRoleEntity(
    builder: RequestBuilder,
    params: { role: string; entity: string }
): Promise<Response> {
    const baseUrl = "/roles/{role}/entities/{entity}"
        .replace("{role}", UrlBuilder.toString(params["role"]))
        .replace("{entity}", UrlBuilder.toString(params["entity"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "POST",
        headers
    };

    return builder.requestBlob(urlBuilder, options);
}

/**
 * Remove the role provided to from the given member.
 * Restrictions:
 * * The calling principal **must** have permission to take the **manageEntities** action against the specified role.
 * * Example: In order to revoke the role, _GroupAdmin_, from an entity a permission with the following would be required:
 * * "action" : "manageEntities"
 * * "resource" : "hrn:here:authorization::myrealm:role/ROLE-c1662138-a170-4264-ba18-7b506a708c37"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Revoke a role from an entity
 * @param role HRN identifying a given role
 * @param entity HRN identifying a given entity
 */
export async function deleteRoleEntity(
    builder: RequestBuilder,
    params: { role: string; entity: string }
): Promise<Response> {
    const baseUrl = "/roles/{role}/entities/{entity}"
        .replace("{role}", UrlBuilder.toString(params["role"]))
        .replace("{entity}", UrlBuilder.toString(params["entity"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "DELETE",
        headers
    };

    return builder.requestBlob(urlBuilder, options);
}

/**
 * Retrieve the list of roles which have been assigned to the calling party.
 * This API works only with tokens that are not scoped to a project.
 *
 * @summary Get My Roles
 * @param pageToken The cursor for pagination. Present only if there is an additional page of data to view.
 * @param count Number of records to return. Default is 100 records. Maximum is 100 records.
 */
export async function getMyRoles(
    builder: RequestBuilder,
    params?: { pageToken?: string; count?: number }
): Promise<RolePageWToken> {
    const baseUrl = "/roles/me";

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    if (params) {
        urlBuilder.appendQuery("pageToken", params["pageToken"]);
        urlBuilder.appendQuery("count", params["count"]);
    }

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<RolePageWToken>(urlBuilder, options);
}

/**
 * Get the role identified by the provided Role HRN.
 *
 * Restrictions:
 * * The calling principal **must** have permission to take the **readRoles** action against the specified realm.
 *
 *  Example:
 * In order to retrieve a role within the realm, _MyRealm_, a permission with the following
 * would be required:
 * * "action" : "readRoles"
 * * "resource" : "hrn:here:account::myrealm:realm/myrealm"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Get Role
 * @param role HRN identifying a given role
 */
export async function getRole(
    builder: RequestBuilder,
    params: { role: string }
): Promise<Role> {
    const baseUrl = "/roles/{role}".replace(
        "{role}",
        UrlBuilder.toString(params["role"])
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<Role>(urlBuilder, options);
}

/**
 * Retrieve the list of entities which have been assigned the role as identified by the provided role HRN.
 *
 * Restrictions:
 * * The calling principal **must** have permission to take the **readEntities** action against the specified role.
 *
 * Example:
 * In order to list the entities assigned the role, _
 * hrn:here:authorization::myrealm:role/ROLE-c1662138-a170-4264-ba18-7b506a708c37_,
 * a permission with the following would be required:
 * * "action" : "readEntities"
 * * "resource" : "hrn:here:authorization::myrealm:role/ROLE-c1662138-a170-4264-ba18-7b506a708c37"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Get role entities
 * @param role HRN identifying a given role
 * @param pageToken The cursor for pagination. Present only if there is an additional page of data to view.
 * @param count Number of records to return. Default is 100 records. Maximum is 100 records.
 */
export async function getRoleEntities(
    builder: RequestBuilder,
    params: { role: string; pageToken?: string; count?: number }
): Promise<RoleEntityPageWToken> {
    const baseUrl = "/roles/{role}/entities".replace(
        "{role}",
        UrlBuilder.toString(params["role"])
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("pageToken", params["pageToken"]);
    urlBuilder.appendQuery("count", params["count"]);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<RoleEntityPageWToken>(urlBuilder, options);
}

/**
 * Retrieve a single entity which has been assigned the role as identified by the provided role HRN.
 *
 * Restrictions:
 * * The calling principal **must** have permission to take the **readEntities** action against the specified role.
 * * Example: In order to retrieve an entity assigned the role, _GroupAdmin_, a permission with the following
 * would be required:
 * * "action" : "readEntities"
 * * "resource" : "hrn:here:authorization::myrealm:role/ROLE-c1662138-a170-4264-ba18-7b506a708c37"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Get a single role entity
 * @param role HRN identifying a given role
 * @param entity HRN identifying a given entity
 */
export async function getRoleEntity(
    builder: RequestBuilder,
    params: { role: string; entity: string }
): Promise<RoleEntity> {
    const baseUrl = "/roles/{role}/entities/{entity}"
        .replace("{role}", UrlBuilder.toString(params["role"]))
        .replace("{entity}", UrlBuilder.toString(params["entity"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<RoleEntity>(urlBuilder, options);
}

/**
 * Get a single permission associated with the role identified by the provided Role HRN.
 *
 * Restrictions:
 * * The calling principal **must** have permission to take the **readPermissions** action against the specified role.
 * * Example: In order to retrieve a single role permission for the specified role in realm _MyRealm_,
 * a permission with the following would be required:
 * * "action" : "readPermissions"
 * * "resource" : "hrn:here:authorization::myrealm:role/ROLE-c1662138-a170-4264-ba18-7b506a708c37"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Get Role Permission
 * @param role HRN identifying a given role
 * @param permission Permission identifier
 */
export async function getRolePermission(
    builder: RequestBuilder,
    params: { role: string; permission: string }
): Promise<ActivePermission> {
    const baseUrl = "/roles/{role}/permissions/{permission}"
        .replace("{role}", UrlBuilder.toString(params["role"]))
        .replace("{permission}", UrlBuilder.toString(params["permission"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<ActivePermission>(urlBuilder, options);
}

/**
 * Get the permissions associated with the role identified by the provided Role HRN.
 *
 * Restrictions:
 * * The calling principal **must** have permission to take the **readPermissions** action against the specified role.
 *
 * Example:
 * In order to list role permissions for the specified role in realm _MyRealm_, a permission with the following
 * would be required:
 * * "action" : "readPermissions"
 * * "resource" : "hrn:here:authorization::myrealm:role/ROLE-c1662138-a170-4264-ba18-7b506a708c37"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Get Role Permissions
 * @param role HRN identifying a given role
 * @param pageToken The cursor for pagination. Present only if there is an additional page of data to view.
 * @param count Number of records to return. Default is 100 records. Maximum is 100 records.
 */
export async function getRolePermissions(
    builder: RequestBuilder,
    params: { role: string; pageToken?: string; count?: number }
): Promise<PermissionPageWToken> {
    const baseUrl = "/roles/{role}/permissions".replace(
        "{role}",
        UrlBuilder.toString(params["role"])
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("pageToken", params["pageToken"]);
    urlBuilder.appendQuery("count", params["count"]);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<PermissionPageWToken>(urlBuilder, options);
}

/**
 * Retrieve the list of roles within the context of the provided realm.
 *
 * Restrictions:
 * * The calling principal **must** have permission to take the **readRoles** action against the specified realm.
 * * Example: In order to list roles within the realm, _MyRealm_, a permission with the following would
 * be required:
 * * "action" : "readRoles"
 * * "resource" : "hrn:here:account::myrealm:realm/myrealm"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Get Roles
 * @param pageToken The cursor for pagination. Present only if there is an additional page of data to view.
 * @param count Number of records to return. Default is 100 records. Maximum is 100 records.
 * @param roleName The name of the role to be returned in the result set.
 * @param resource The hrn of the resource which the roles returned in the result set should be associated with.
 */
export async function getRoles(
    builder: RequestBuilder,
    params?: {
        pageToken?: string;
        count?: number;
        roleName?: string;
        resource?: string;
    }
): Promise<RolePageWToken> {
    const baseUrl = "/roles";

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    if (params) {
        urlBuilder.appendQuery("pageToken", params["pageToken"]);
        urlBuilder.appendQuery("count", params["count"]);
        urlBuilder.appendQuery("roleName", params["roleName"]);
        urlBuilder.appendQuery("resource", params["resource"]);
    }

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<RolePageWToken>(urlBuilder, options);
}

/**
 * ===================================================================
 * GroupsApi
 * ===================================================================
 */

/**
 * Add a single member to a group.
 *
 * Restrictions:
 * * The calling principal **must** have permission to take the **manageMembers** action against the group
 * identified by the provided group HRN.
 *
 * * Example:
 * In order to add a member to the group, _GROUP-8e270653-f592-45a8-88d7-46d409ccfa8a_, a permission with the following would
 * be required:
 * * "action" : "manageMembers"
 * * "resource" : "hrn:here:authorization::myrealm:group/GROUP-8e270653-f592-45a8-88d7-46d409ccfa8a"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Add a member to a group
 * @param groupId HRN identifying a group.
 * @param member HRN identifying group or realm member
 */
export async function addGroupMember(
    builder: RequestBuilder,
    params: { groupId: string; member: string }
): Promise<Response> {
    const baseUrl = "/groups/{groupId}/members/{member}"
        .replace("{groupId}", UrlBuilder.toString(params["groupId"]))
        .replace("{member}", UrlBuilder.toString(params["member"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "POST",
        headers
    };

    return builder.requestBlob(urlBuilder, options);
}

/**
 * Create a group within the realm that is associated with the calling party.
 * The calling party will be made a member and an administrator of the created group.
 *
 * Restrictions:
 * * The calling principal **must** have permission to take the **createGroup** action
 * against the realm associated with the calling party.
 *
 * * Example:
 * In order to create a group within the calling party's realm a permission with the following would be required:
 * * "action" : "createGroup"
 * * "resource" : "hrn:here:account::myrealm:realm/myrealm"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Create group
 * @param body
 */
export async function createGroup(
    builder: RequestBuilder,
    params: { body: Group }
): Promise<Group> {
    const baseUrl = "/groups";

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "POST",
        headers
    };
    headers["Content-Type"] = "application/json";
    if (params["body"] !== undefined) {
        options.body = JSON.stringify(params["body"]);
    }

    return builder.request<Group>(urlBuilder, options);
}

/**
 * Delete the group identified by the provided group HRN.
 *
 * Restrictions:
 * * The calling principal **must** have permission to take
 * the **deleteGroup** action against the group identified by the provided group HRN.
 *
 * * Example:
 * In order to delete the group, _GROUP-8e270653-f592-45a8-88d7-46d409ccfa8a_,
 * a permission with the following would be required:
 * * "action" : "deleteGroup"
 * * "resource" : "hrn:here:authorization::myrealm:group/GROUP-8e270653-f592-45a8-88d7-46d409ccfa8a"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary delete group
 * @param groupId HRN identifying a group.
 */
export async function deleteGroup(
    builder: RequestBuilder,
    params: { groupId: string }
): Promise<Response> {
    const baseUrl = "/groups/{groupId}".replace(
        "{groupId}",
        UrlBuilder.toString(params["groupId"])
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "DELETE",
        headers
    };

    return builder.requestBlob(urlBuilder, options);
}

/**
 * Retrieve the group identified by the provided group HRN.
 *
 * Restrictions:
 * * The calling principal **must** have permission to take the **readMembers** action
 * against the realm associated with the calling party.
 *
 * * Example:
 * In order to retrieve a group within the calling party's realm a permission
 * with the following would be required:
 * * "action" : "readMembers"
 * * "resource" : "hrn:here:account::myrealm:realm/myrealm"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Get single group
 * @param groupId HRN identifying a group.
 */
export async function getGroup(
    builder: RequestBuilder,
    params: { groupId: string }
): Promise<Group> {
    const baseUrl = "/groups/{groupId}".replace(
        "{groupId}",
        UrlBuilder.toString(params["groupId"])
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<Group>(urlBuilder, options);
}

/**
 * Retrieve a single group member.
 *
 * Restrictions:
 * * The calling principal **must** have permission to take the **readMembers** action against
 * the group identified by the provided group HRN.
 *
 * * Example:
 * In order to retrieve a single member of the group, _GROUP-8e270653-f592-45a8-88d7-46d409ccfa8a_,
 * a permission with the following would be required:
 * * "action" : "readMembers"
 * * "resource" : "hrn:here:authorization::myrealm:group/GROUP-8e270653-f592-45a8-88d7-46d409ccfa8a"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Get single Group member
 * @param groupId HRN identifying a group.
 * @param member HRN identifying group or realm member
 */
export async function getGroupMember(
    builder: RequestBuilder,
    params: { groupId: string; member: string }
): Promise<GroupMember> {
    const baseUrl = "/groups/{groupId}/members/{member}"
        .replace("{groupId}", UrlBuilder.toString(params["groupId"]))
        .replace("{member}", UrlBuilder.toString(params["member"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<GroupMember>(urlBuilder, options);
}

/**
 * Retrieve the list of members of the group identified by the provided group HRN.
 *
 * Restrictions:
 * * The calling principal **must** have permission to take the **readMembers** action against the group
 * identified by the provided group HRN.
 *
 * * Example: In order to retrieve the members of the group, _GROUP-8e270653-f592-45a8-88d7-46d409ccfa8a_,
 * a permission with the following would be required:
 * * "action" : "readMembers"
 * * "resource" : "hrn:here:authorization::myrealm:group/GROUP-8e270653-f592-45a8-88d7-46d409ccfa8a"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Get Group members
 * @param groupId HRN identifying a group.
 * @param pageToken The cursor for pagination. Present only if there is an additional page of data to view.
 * @param count Number of records to return. Default is 100 records. Maximum is 100 records.
 * @param entityType The type of members to return in the result.
 * One of 'user', 'app', or 'invite'.  If this parameter is omitted, all entity types will be returned.
 */
export async function getGroupMembers(
    builder: RequestBuilder,
    params: {
        groupId: string;
        pageToken?: string;
        count?: number;
        entityType?: string;
    }
): Promise<GroupMemberPageWToken> {
    const baseUrl = "/groups/{groupId}/members".replace(
        "{groupId}",
        UrlBuilder.toString(params["groupId"])
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("pageToken", params["pageToken"]);
    urlBuilder.appendQuery("count", params["count"]);
    urlBuilder.appendQuery("entityType", params["entityType"]);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<GroupMemberPageWToken>(urlBuilder, options);
}

/**
 * List the roles which are associated with the provided group.
 *
 * Restrictions:
 * * The calling principal **must** have permission to take the **readRoles** action against the specified group.
 * * Example: In order list the roles associated with the group, _GROUP-8e270653-f592-45a8-88d7-46d409ccfa8a_,
 * a permission with the following would be required:
 * * "action" : "readRoles"
 * * "resource" : "hrn:here:authorization::myrealm:group/GROUP-8e270653-f592-45a8-88d7-46d409ccfa8a"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Get group roles
 * @param groupId HRN identifying a group.
 * @param pageToken The cursor for pagination. Present only if there is an additional page of data to view.
 * @param count Number of records to return. Default is 100 records. Maximum is 100 records.
 */
export async function getGroupRoles(
    builder: RequestBuilder,
    params: { groupId: string; pageToken?: string; count?: number }
): Promise<RolePageWToken> {
    const baseUrl = "/groups/{groupId}/roles".replace(
        "{groupId}",
        UrlBuilder.toString(params["groupId"])
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("pageToken", params["pageToken"]);
    urlBuilder.appendQuery("count", params["count"]);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<RolePageWToken>(urlBuilder, options);
}

/**
 * Retrieve the list of groups within the realm associated with the calling party.
 *
 * Restrictions:
 * * The calling principal **must** have permission to take the **readMembers** action against the realm associated with the calling party.
 *
 * * Example:
 * In order to list the groups within the calling party's realm a permission with the following would be required:
 * * "action" : "readMembers"
 * * "resource" : "hrn:here:account::myrealm:realm/myrealm"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Get groups
 * @param pageToken The cursor for pagination. Present only if there is an additional page of data to view.
 * @param count Number of records to return. Default is 100 records. Maximum is 100 records.
 * @param q A free text query string used to filter the results.
 * A search against groups in the realm will consider the 'id', 'name', and 'description' fields of the groups.
 * The precise search algorithm used to match groups is not specified, but generally any member where
 * one of the considered fields has a full or partial match should be included in the results.
 */
export async function getGroups(
    builder: RequestBuilder,
    params?: { pageToken?: string; count?: number; q?: string }
): Promise<GroupPageWToken> {
    const baseUrl = "/groups";

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    if (params) {
        urlBuilder.appendQuery("pageToken", params["pageToken"]);
        urlBuilder.appendQuery("count", params["count"]);
        urlBuilder.appendQuery("q", params["q"]);
    }

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<GroupPageWToken>(urlBuilder, options);
}

/**
 * Retrieve a list of groups of a member
 *
 * This API works only with tokens that are not scoped to a project.
 *
 * @summary Get My Groups
 * @param pageToken The cursor for pagination. Present only if there is an additional page of data to view.
 * @param count Number of records to return. Default is 100 records. Maximum is 100 records.
 */
export async function getMyGroups(
    builder: RequestBuilder,
    params?: { pageToken?: string; count?: number }
): Promise<GroupPageWToken> {
    const baseUrl = "/groups/me";

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    if (params) {
        urlBuilder.appendQuery("pageToken", params["pageToken"]);
        urlBuilder.appendQuery("count", params["count"]);
    }

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<GroupPageWToken>(urlBuilder, options);
}

/**
 * Remove the calling party from the group. This operation will also remove administrative roles from this member.
 * This API works only with tokens that are not scoped to a project.
 *
 * @summary Removes the calling party from a group
 * @param groupId HRN identifying a group.
 */
export async function leaveGroup(
    builder: RequestBuilder,
    params: { groupId: string }
): Promise<Response> {
    const baseUrl = "/groups/{groupId}/members/me".replace(
        "{groupId}",
        UrlBuilder.toString(params["groupId"])
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "DELETE",
        headers
    };

    return builder.requestBlob(urlBuilder, options);
}

/**
 * Remove a member from the group. This operation will also remove administrative roles from this member.
 *
 * Restrictions:
 * * The calling principal **must** have permission to take the **manageMembers**
 * action against the group identified by the provided group HRN.
 *
 * * Example:
 * In order to remove a member from the group, _GROUP-8e270653-f592-45a8-88d7-46d409ccfa8a_,
 * a permission with the following would be required:
 * * "action" : "manageMembers"
 * * "resource" : "hrn:here:authorization::myrealm:group/GROUP-8e270653-f592-45a8-88d7-46d409ccfa8a"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Remove a member from the group.
 * @param groupId HRN identifying a group.
 * @param member HRN identifying group or realm member
 */
export async function removeGroupMember(
    builder: RequestBuilder,
    params: { groupId: string; member: string }
): Promise<Response> {
    const baseUrl = "/groups/{groupId}/members/{member}"
        .replace("{groupId}", UrlBuilder.toString(params["groupId"]))
        .replace("{member}", UrlBuilder.toString(params["member"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "DELETE",
        headers
    };

    return builder.requestBlob(urlBuilder, options);
}

/**
 * Update the group identified by the provided group HRN by updating all writable group fields including name and description.
 *
 * Restrictions:
 * * The calling principal **must** have permission to take the  **updateGroup** action
 * against the group identified by the provided group HRN.
 *
 * * Example:
 * In order to modify the group, _GROUP-8e270653-f592-45a8-88d7-46d409ccfa8a_, a permission with the following
 * would be required:
 * * "action" : "updateGroup"
 * * "resource" : "hrn:here:authorization::myrealm:group/GROUP-8e270653-f592-45a8-88d7-46d409ccfa8a"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Update group
 * @param body
 * @param groupId HRN identifying a group.
 */
export async function updateGroup(
    builder: RequestBuilder,
    params: { body: Group; groupId: string }
): Promise<Group> {
    const baseUrl = "/groups/{groupId}".replace(
        "{groupId}",
        UrlBuilder.toString(params["groupId"])
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "POST",
        headers
    };
    headers["Content-Type"] = "application/json";
    if (params["body"] !== undefined) {
        options.body = JSON.stringify(params["body"]);
    }

    return builder.request<Group>(urlBuilder, options);
}

/**
 * ===================================================================
 * ProjectsApi
 * ===================================================================
 */

/**
 * Add the member to the requested Project.
 *
 * Access Control:
 * * User Access Token & Client Access Token
 * * The calling principal **must** have permission to take the **manageMembers** action for the specified resource.
 *
 * * Example:
 * In order to add a member to the Project, the following permission would be required:
 * * "action" : "manageMembers"
 * * "resource" : "hrn:here:authorization::myrealm:project/my-project-0000"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Add the member to the requested Project
 * @param project HRN identifying the project
 * @param member HRN identifying the project member. Either user, app or group
 * @param xCorrelationID Correlates HTTP requests between a client and server.
 * If not present in the incoming request, it will be generated.
 */
export async function addProjectMember(
    builder: RequestBuilder,
    params: { project: string; member: string; xCorrelationID?: string }
): Promise<Response> {
    const baseUrl = "/projects/{project}/members/{member}"
        .replace("{project}", UrlBuilder.toString(params["project"]))
        .replace("{member}", UrlBuilder.toString(params["member"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "POST",
        headers
    };
    if (params["xCorrelationID"] !== undefined) {
        headers["X-Correlation-ID"] = params["xCorrelationID"] as string;
    }

    return builder.requestBlob(urlBuilder, options);
}

/**
 * Add the resource to the requested Project as a home or a reference(link).
 *
 * Access Control:
 * * User Access Token & Client Access Token  **When relation=home**
 * The requested resource will be assigned the requested project as its resource home.
 * The resource **MUST NOT** already have an existing resource home.
 *
 * * The calling principal **must** have permission to take the **manageResourceHome** action for the specified project **AND**
 * the **share** action for the specified resource.
 *
 * * Example: In order to add resource "hrn:here:data::myrealm:my-catalog-0000" to the project
 * "hrn:here:authorization::myrealm:project/my-project-0000", the following permissions would be required:
 * * Permission 1:
 * * "action" : "manageResourceHome"
 * * "resource" : "hrn:here:authorization::myrealm:project/my-project-0000"
 *
 * * Permission 2:
 * * "action" : "share"
 * * "resource" : "hrn:here:data::myrealm:my-catalog-0000" **When relation=reference**
 * Link the resource to the requested Project as a reference(link).
 * The requested resource will be assigned to the requested project as reference(link).
 *
 * The resource **MUST** be available to the caller to attach as a resource reference(link).
 * A resource is referenceable if it has been marked as referenceable and the caller has permission to all reference enabled actions
 * against the resource OR The resource has been made linkable to the project/realm for the project linking enabled action
 * The exclusive list of resources available to the caller to attach as a resource reference(link) is accessible via a call
 * to /resources?referenceable=true or /resources?linkable=true
 *
 * * The authorization context **must** satisfy one of the following:
 * * The calling principal has permission to take the **manageResourceReferences** action for the specified project.
 * * Example: In order to add a resource reference to the project "hrn:here:authorization::myrealm:project/my-project-0000",
 * the following permission would be required:
 * * "action" : "manageResourceReferences"
 * * "resource" : "hrn:here:authorization::myrealm:project/my-project-0000"
 * * The calling principal is a **member** of the specified project.
 * * The calling principal **must** have permission to attach the resource as a referenceable resource.
 * A resource is referenceable to the caller if:
 * * It has been marked as referenceable and The caller has permission to all reference enabled actions against the resource.
 *
 * OR
 *
 * * The resource has been made linkable to the project/realm for the project linking enabled action
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Add a resource to the requested Project as a Resource Home or Resource Reference(Link)
 * @param body
 * @param project HRN identifying the project
 * @param resource The hrn that identifies the resource.
 * @param relation The relation of the resource. Must be home or reference(link)
 * @param type The type of the resource.
 * @param xCorrelationID Correlates HTTP requests between a client and server.
 * If not present in the incoming request, it will be generated.
 */
export async function addProjectResourceRelation(
    builder: RequestBuilder,
    params: {
        body: ResourceLinkActionBody;
        project: string;
        resource: string;
        relation: ResourceRelation;
        type: Type;
        xCorrelationID?: string;
    }
): Promise<ResourceRelationResponse> {
    const baseUrl = "/projects/{project}/resources/{resource}"
        .replace("{project}", UrlBuilder.toString(params["project"]))
        .replace("{resource}", UrlBuilder.toString(params["resource"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("relation", params["relation"]);
    urlBuilder.appendQuery("type", params["type"]);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "POST",
        headers
    };
    headers["Content-Type"] = "application/json";
    if (params["body"] !== undefined) {
        options.body = JSON.stringify(params["body"]);
    }
    if (params["xCorrelationID"] !== undefined) {
        headers["X-Correlation-ID"] = params["xCorrelationID"] as string;
    }

    return builder.request<ResourceRelationResponse>(urlBuilder, options);
}

/**
 * Checks whether a project exists with requested project hrn in caller realm.
 *
 * If project does not exist in the same realm it will return 404.
 *
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Checks the existance of a project in caller realm.
 * @param project HRN identifying the project
 * @param xCorrelationID Correlates HTTP requests between a client and server.
 * If not present in the incoming request, it will be generated.
 */
export async function checkProjectExistance(
    builder: RequestBuilder,
    params: { project: string; xCorrelationID?: string }
): Promise<Response> {
    const baseUrl = "/projects/{project}".replace(
        "{project}",
        UrlBuilder.toString(params["project"])
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "HEAD",
        headers
    };
    if (params["xCorrelationID"] !== undefined) {
        headers["X-Correlation-ID"] = params["xCorrelationID"] as string;
    }

    return builder.requestBlob(urlBuilder, options);
}

/**
 * Create the requested Project in the callers realm
 * Access Control:
 * * User Access Token & Client Access Token
 * * The calling principal **must** have permission to take the **createProject** action for the specified project.
 *
 * * Example:
 * In order to create a Project, the following permission would be required:
 * * "action" : "createProject"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Create the requested Project
 * @param body
 * @param xCorrelationID Correlates HTTP requests between a client and server.
 * If not present in the incoming request, it will be generated.
 */
export async function createProject(
    builder: RequestBuilder,
    params: { body: ProjectRequest; xCorrelationID?: string }
): Promise<ProjectResponse> {
    const baseUrl = "/projects";

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "POST",
        headers
    };
    headers["Content-Type"] = "application/json";
    if (params["body"] !== undefined) {
        options.body = JSON.stringify(params["body"]);
    }
    if (params["xCorrelationID"] !== undefined) {
        headers["X-Correlation-ID"] = params["xCorrelationID"] as string;
    }

    return builder.request<ProjectResponse>(urlBuilder, options);
}

/**
 * Delete the specified Project
 * Access Control:
 * * User Access Token & Client Access Token
 * * The calling principal **must** have permission to take the **manage** action for the specified resource.
 * * Example: In order to delete a Project, the following permission would be required:
 * * "action" : "manage"
 * * "resource" : "hrn:here:authorization::myrealm:project/my-project-0000"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Delete the specified Project
 * @param project HRN identifying the project
 * @param xCorrelationID Correlates HTTP requests between a client and server. If not present in the incoming request, it will be generated.
 */
export async function deleteProject(
    builder: RequestBuilder,
    params: { project: string; xCorrelationID?: string }
): Promise<Response> {
    const baseUrl = "/projects/{project}".replace(
        "{project}",
        UrlBuilder.toString(params["project"])
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "DELETE",
        headers
    };
    if (params["xCorrelationID"] !== undefined) {
        headers["X-Correlation-ID"] = params["xCorrelationID"] as string;
    }

    return builder.requestBlob(urlBuilder, options);
}

/**
 * Remove the member from the specified Project
 * Access Control:
 * * User Access Token & Client Access Token
 * * The calling principal **must** have permission to take the **manageMembers** action for the specified resource.
 *
 * * Example:
 * In order to remove a member from a Project, the following permission would be required:
 * * "action" : "manageMembers"
 * * "resource" : "hrn:here:authorization::myrealm:project/my-project-0000"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Remove the member from the specified Project
 * @param project HRN identifying the project
 * @param member HRN identifying the project member. Either user, app or group
 * @param xCorrelationID Correlates HTTP requests between a client and server. If not present in the incoming request, it will be generated.
 */
export async function deleteProjectMember(
    builder: RequestBuilder,
    params: { project: string; member: string; xCorrelationID?: string }
): Promise<Response> {
    const baseUrl = "/projects/{project}/members/{member}"
        .replace("{project}", UrlBuilder.toString(params["project"]))
        .replace("{member}", UrlBuilder.toString(params["member"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "DELETE",
        headers
    };
    if (params["xCorrelationID"] !== undefined) {
        headers["X-Correlation-ID"] = params["xCorrelationID"] as string;
    }

    return builder.requestBlob(urlBuilder, options);
}

/**
 * Remove the resource from the project.
 * The requested resource may only be linked as a reference, removing a home resource requires deleting the resource from the
 * resource service.
 *
 * Access Control:
 * * User Access Token & Client Access Token
 * * The calling principal **must** have permission to take the **manageResourceReferences** action for the specified project.
 *
 * * Example:
 * In order to remove a resource reference(link) from the project
 * "hrn:here:authorization::myrealm:project/my-project-0000", the following permission would be required:
 * * "action" : "manageResourceReferences"
 * * "resource" : "hrn:here:authorization::myrealm:project/my-project-0000"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Remove a Resource Reference(Link) from a project
 * @param body
 * @param project HRN identifying the project
 * @param resource The hrn that identifies the resource.
 * @param relation The relation of the resource. Must be reference(link)
 * @param xCorrelationID Correlates HTTP requests between a client and server. If not present in the incoming request, it will be generated.
 */
export async function deleteProjectResourceReference(
    builder: RequestBuilder,
    params: {
        body: ResourceLinkActionBody;
        project: string;
        resource: string;
        relation: string;
        xCorrelationID?: string;
    }
): Promise<Response> {
    const baseUrl = "/projects/{project}/resources/{resource}"
        .replace("{project}", UrlBuilder.toString(params["project"]))
        .replace("{resource}", UrlBuilder.toString(params["resource"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("relation", params["relation"]);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "DELETE",
        headers
    };
    headers["Content-Type"] = "application/json";
    if (params["body"] !== undefined) {
        options.body = JSON.stringify(params["body"]);
    }
    if (params["xCorrelationID"] !== undefined) {
        headers["X-Correlation-ID"] = params["xCorrelationID"] as string;
    }

    return builder.requestBlob(urlBuilder, options);
}

/**
 * Get the list of all Projects in the Org
 *
 * Access Control:
 * * User Access Token & Client Access Token
 * * The calling principal **must** have permission to take the **listAllProjects** action for the specified resource.
 *
 * * Example:
 * In order to get a list of projects, the following permission would be required:
 * * "action" : "listAllProjects"
 *
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Get the list of all Projects in the Org
 * @param limit Number of entries to be returned in the response.
 * @param pageToken The cursor for pagination. Present only if there is an additional page of data to view.
 * @param xCorrelationID Correlates HTTP requests between a client and server. If not present in the incoming request, it will be generated.
 */
export async function getAllProjectList(
    builder: RequestBuilder,
    params: { limit?: number; pageToken?: string; xCorrelationID?: string }
): Promise<ProjectListWithPageToken> {
    const baseUrl = "/projects";

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("limit", params["limit"]);
    urlBuilder.appendQuery("pageToken", params["pageToken"]);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };
    if (params["xCorrelationID"] !== undefined) {
        headers["X-Correlation-ID"] = params["xCorrelationID"] as string;
    }

    return builder.request<ProjectListWithPageToken>(urlBuilder, options);
}

/**
 * Get the requested Project
 *
 * Access Control:
 * * User Access Token & Client Access Token
 * * The calling principal **must** have permission to take the **read** action for the specified resource.
 *
 * * Example:
 * In order to get a project, the following permission would be required:
 * * "action" : "read"
 * * "resource" : "hrn:here:authorization::myrealm:project/my-project-0000"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Get the requested Project
 * @param project HRN identifying the project
 * @param xCorrelationID Correlates HTTP requests between a client and server. If not present in the incoming request, it will be generated.
 */
export async function getProject(
    builder: RequestBuilder,
    params: { project: string; xCorrelationID?: string }
): Promise<ProjectResponse> {
    const baseUrl = "/projects/{project}".replace(
        "{project}",
        UrlBuilder.toString(params["project"])
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };
    if (params["xCorrelationID"] !== undefined) {
        headers["X-Correlation-ID"] = params["xCorrelationID"] as string;
    }

    return builder.request<ProjectResponse>(urlBuilder, options);
}

/**
 * Get the list of Projects you are a  project admin or a member based on the "canManage" or "isMember" parameter's value.
 *
 * @note If neither "canManage" nor "isMember" is specified, "isMember=true" projects are returned.
 * Supported values for "canManage" / "isMember" is : [true]
 *
 * Access Control:
 * * User Access Token & Client Access Token
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Get the list of Projects that you are a project admin or a member based on the "canManage" or "isMember" parameter's value
 * @param xCorrelationID Correlates HTTP requests between a client and server. If not present in the incoming request, it will be generated.
 * @param limit Number of entries to be returned in the response.
 * @param pageToken The cursor for pagination. Present only if there is an additional page of data to view.
 * @param canManage if true returns all projects of which the caller(user/app) is a project admin.
 * @param isMember if true returns all projects of which the caller(user/app) is a member.
 */
export async function getProjectList(
    builder: RequestBuilder,
    params: {
        xCorrelationID?: string;
        limit?: number;
        pageToken?: string;
        canManage?: boolean;
        isMember?: boolean;
    }
): Promise<ProjectListWithPageToken> {
    const baseUrl = "/projects/me";

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("limit", params["limit"]);
    urlBuilder.appendQuery("pageToken", params["pageToken"]);
    urlBuilder.appendQuery("canManage", `${params["canManage"]}`);
    urlBuilder.appendQuery("isMember", `${params["isMember"]}`);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };
    if (params["xCorrelationID"] !== undefined) {
        headers["X-Correlation-ID"] = params["xCorrelationID"] as string;
    }

    return builder.request<ProjectListWithPageToken>(urlBuilder, options);
}

/**
 * Get the requested Project Member
 *
 * Access Control:
 * * User Access Token & Client Access Token
 * * The calling principal **must** have permission to take the **read** action for the specified resource.
 * * Example: In order to get a member of a Project, the following permission would be required:
 * * "action" : "read"
 * * "resource" : "hrn:here:authorization::myrealm:project/my-project-0000"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Get the requested Project Member
 * @param project HRN identifying the project
 * @param member HRN identifying the project member. Either user, app or group
 * @param xCorrelationID Correlates HTTP requests between a client and server. If not present in the incoming request, it will be generated.
 */
export async function getProjectMember(
    builder: RequestBuilder,
    params: { project: string; member: string; xCorrelationID?: string }
): Promise<ProjectMember> {
    const baseUrl = "/projects/{project}/members/{member}"
        .replace("{project}", UrlBuilder.toString(params["project"]))
        .replace("{member}", UrlBuilder.toString(params["member"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };
    if (params["xCorrelationID"] !== undefined) {
        headers["X-Correlation-ID"] = params["xCorrelationID"] as string;
    }

    return builder.request<ProjectMember>(urlBuilder, options);
}

/**
 * Get the resource that is linked to the requested Project.
 *
 * The requested resource may be linked as either a home or a reference(link).
 *
 * Access Control:
 * * User Access Token & Client Access Token
 * * The calling principal **must** have permission to take the **read** action for the specified project
 *
 * * Example: In order to get resource "hrn:here:data::myrealm:my-catalog-0000" in the project
 * "hrn:here:authorization::myrealm:project/my-project-0000", the following permission would be required:
 *
 * * "action" : "read"
 * * "resource" : "hrn:here:authorization::myrealm:project/my-project-0000"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Get a resource that is linked to a Project as either a Resource Home or Resource Reference(Link)
 * @param project HRN identifying the project
 * @param resource The hrn that identifies the resource.
 * @param relation The relation of the resource. A resource is only returned in the response if it matches the requested relation.
 * @param xCorrelationID Correlates HTTP requests between a client and server. If not present in the incoming request, it will be generated.
 */
export async function getProjectResource(
    builder: RequestBuilder,
    params: {
        project: string;
        resource: string;
        relation?: Relation;
        xCorrelationID?: string;
    }
): Promise<ResourceInProjectResponse> {
    const baseUrl = "/projects/{project}/resources/{resource}"
        .replace("{project}", UrlBuilder.toString(params["project"]))
        .replace("{resource}", UrlBuilder.toString(params["resource"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("relation", params["relation"]);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };
    if (params["xCorrelationID"] !== undefined) {
        headers["X-Correlation-ID"] = params["xCorrelationID"] as string;
    }

    return builder.request<ResourceInProjectResponse>(urlBuilder, options);
}

/**
 * Remove the caller from the specified Project
 *
 * Access Control:
 * * User Access Token & Client Access Token
 * * Authorization : None
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Remove the caller from the specified Project
 * @param project HRN identifying the project
 * @param xCorrelationID Correlates HTTP requests between a client and server. If not present in the incoming request, it will be generated.
 */
export async function leaveProject(
    builder: RequestBuilder,
    params: { project: string; xCorrelationID?: string }
): Promise<Response> {
    const baseUrl = "/projects/{project}/members/me".replace(
        "{project}",
        UrlBuilder.toString(params["project"])
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "DELETE",
        headers
    };
    if (params["xCorrelationID"] !== undefined) {
        headers["X-Correlation-ID"] = params["xCorrelationID"] as string;
    }

    return builder.requestBlob(urlBuilder, options);
}

/**
 * Get the list of members of the Project
 *
 * Access Control:
 * * User Access Token & Client Access Token
 * * The calling principal **must** have permission to take the **read** action for the specified resource.
 *
 * * Example:
 * In order to get a list of project members, the following permission would be required:
 * * "action" : "read"
 * * "resource" : "hrn:here:authorization::myrealm:project/my-project-0000"
 * * This API works only with tokens that are not scoped to a project.
 * * if 'onlyIncludeIdentities' query parameter is set to true, 'total' is NOT returned in Response
 *
 * @summary Get the list of members of the Project
 * @param project HRN identifying the project
 * @param onlyIncludeIdentities If true, returns an effective project members list containing only user and app identities,
 * including those that are members of the project indirectly via a group.
 * It will also return users who are project admins of the specified project, and Resource Managers for the realm.
 * Response will NOT include total number of identities.
 * If false, returns users, apps, and groups that are direct members of the project, excluding any users and apps that only have
 * membership via a group. Defaults to false.  Suppose there are a user U and a group G with app A in it.
 * Suppose user U and group G are the members of the project, then * onlyIncludeIdentities: true will return U and A
 * * onlyIncludeIdentities:false or absent will return U and G
 * @param xCorrelationID Correlates HTTP requests between a client and server. If not present in the incoming request, it will be generated.
 * @param limit Number of entries to be returned in the response.
 * @param pageToken The cursor for pagination. Present only if there is an additional page of data to view.
 */
export async function listProjectMembers(
    builder: RequestBuilder,
    params: {
        project: string;
        onlyIncludeIdentities?: boolean;
        xCorrelationID?: string;
        limit?: number;
        pageToken?: string;
    }
): Promise<ProjectMemberListWithPageToken> {
    const baseUrl = "/projects/{project}/members".replace(
        "{project}",
        UrlBuilder.toString(params["project"])
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery(
        "onlyIncludeIdentities",
        `${params["onlyIncludeIdentities"]}`
    );
    urlBuilder.appendQuery("limit", params["limit"]);
    urlBuilder.appendQuery("pageToken", params["pageToken"]);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };
    if (params["xCorrelationID"] !== undefined) {
        headers["X-Correlation-ID"] = params["xCorrelationID"] as string;
    }

    return builder.request<ProjectMemberListWithPageToken>(urlBuilder, options);
}

/**
 * Get the list of resources in the requested Project & referenced in(linked to) the Project
 *
 * Access Control:
 * * User Access Token & Client Access Token
 * * The calling principal **must** have permission to take the **read** action for the specified resource.
 *
 * * Example:
 * In order to get the list of resources in the Project, the following permission would be required:
 * * "action" : "read"
 * * "resource" : "hrn:here:authorization::myrealm:project/my-project-0000"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Get the list of resources in the requested Project & referenced in(linked to) the Project
 * @param project HRN identifying the project
 * @param type The type of the resource.
 * @param relation The relation of the resource. A resource is only returned in the response if it matches the requested relation.
 * @param limit Number of entries to be returned in the response.
 * @param pageToken The cursor for pagination. Present only if there is an additional page of data to view.
 * @param xCorrelationID Correlates HTTP requests between a client and server. If not present in the incoming request, it will be generated.
 */
export async function listProjectResources(
    builder: RequestBuilder,
    params: {
        project: string;
        type?: Type;
        relation?: Relation;
        limit?: number;
        pageToken?: string;
        xCorrelationID?: string;
    }
): Promise<ResourceInProjectListWithPageToken> {
    const baseUrl = "/projects/{project}/resources".replace(
        "{project}",
        UrlBuilder.toString(params["project"])
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("type", params["type"]);
    urlBuilder.appendQuery("relation", params["relation"]);
    urlBuilder.appendQuery("limit", params["limit"]);
    urlBuilder.appendQuery("pageToken", params["pageToken"]);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };
    if (params["xCorrelationID"] !== undefined) {
        headers["X-Correlation-ID"] = params["xCorrelationID"] as string;
    }

    return builder.request<ResourceInProjectListWithPageToken>(
        urlBuilder,
        options
    );
}

/**
 * Update the specified Project
 *
 * Access Control:
 * * User Access Token & Client Access Token
 * * The calling principal **must** have permission to take the **write** action for the specified resource.
 * *
 * Example:
 * In order to update a Project, the following permission would be required:
 * * "action" : "write"
 * * "resource" : "hrn:here:authorization::myrealm:project/my-project-0000"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Update the specified Project
 * @param body
 * @param project HRN identifying the project
 * @param xCorrelationID Correlates HTTP requests between a client and server. If not present in the incoming request, it will be generated.
 */
export async function patchProject(
    builder: RequestBuilder,
    params: { body: PatchProject; project: string; xCorrelationID?: string }
): Promise<ProjectResponse> {
    const baseUrl = "/projects/{project}".replace(
        "{project}",
        UrlBuilder.toString(params["project"])
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "PATCH",
        headers
    };
    headers["Content-Type"] = "application/json";
    if (params["body"] !== undefined) {
        options.body = JSON.stringify(params["body"]);
    }
    if (params["xCorrelationID"] !== undefined) {
        headers["X-Correlation-ID"] = params["xCorrelationID"] as string;
    }

    return builder.request<ProjectResponse>(urlBuilder, options);
}

/**
 * ===================================================================
 * Resource Info And Management Api
 * ===================================================================
 */

/**
 * Get a list of ways this resource has been made linkable
 *
 * Access Control:
 * * The calling principal **must** have permission to take all the "requiredToMakeLinkable" actions against
 * the service inferred via the reserved resource prefix of the resource in the path in the scope of the   home project of the resource.
 *
 * * Example:
 * In order to make a catalog linkable, the following permission would be required:
 * * "action" : "manageResource"
 * * "resource" : "hrn:here:data::olp-here:my-shared-catalog"
 *
 * This API works only with tokens that are scoped to the home project of the resource.
 *
 * @summary Get a list of ways the resource has been made linkable
 * @param resource The hrn that identifies the resource.
 * @param xCorrelationID Correlates HTTP requests between a client and server.
 * If not present in the incoming request, it will be generated.
 * @param limit Number of entries to be returned in the response.
 * @param pageToken The cursor for pagination. Present only if there is an additional page of data to view.
 */
export async function getListOfWaysResourceIsLinkable(
    builder: RequestBuilder,
    params: {
        resource: string;
        xCorrelationID?: string;
        limit?: number;
        pageToken?: string;
    }
): Promise<LinkableResourceList> {
    const baseUrl = "/resources/{resource}/linkable".replace(
        "{resource}",
        UrlBuilder.toString(params["resource"])
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("limit", params["limit"]);
    urlBuilder.appendQuery("pageToken", params["pageToken"]);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };
    if (params["xCorrelationID"] !== undefined) {
        headers["X-Correlation-ID"] = params["xCorrelationID"] as string;
    }

    return builder.request<LinkableResourceList>(urlBuilder, options);
}

/**
 * Get the Resource that the caller is allowed to see based on the input query parameters
 *
 * This API works only with tokens that are not scoped to a project.
 *
 * @summary Get a single resource
 * @param resource The hrn that identifies the resource.
 * @param referenceable Get the resource only if it is available to the caller to attach as a reference to projects.
 * A resource is referenceable if it is marked as referenceable and the caller has permission to all reference enabled actions
 * against the resource.  Otherwise 404.  Only supported value is true.
 * @param xCorrelationID Correlates HTTP requests between a client and server.
 * If not present in the incoming request, it will be generated.
 */
export async function getResource(
    builder: RequestBuilder,
    params: {
        resource: string;
        referenceable: boolean;
        xCorrelationID?: string;
    }
): Promise<ResourceResponse> {
    const baseUrl = "/resources/{resource}".replace(
        "{resource}",
        UrlBuilder.toString(params["resource"])
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("referenceable", `${params["referenceable"]}`);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };
    if (params["xCorrelationID"] !== undefined) {
        headers["X-Correlation-ID"] = params["xCorrelationID"] as string;
    }

    return builder.request<ResourceResponse>(urlBuilder, options);
}

/**
 * Get the availability for linking this resource to either a project or realm.
 *
 * Access Control:
 * * The calling principal **must** have permission to take all the "requiredToMakeLinkable" actions against
 * the service inferred via the reserved resource prefix of the resource in the path in the scope of the   home project of the resource.
 *
 * * Example: In order to get the catalog linkability, the following permission would be required:
 * * "action" : "manageResource"
 * * "resource" : "hrn:here:data::olp-here:my-shared-catalog"
 * This API works only with tokens that are scoped to the home project of the resource.
 *
 * @summary Get the linkability of a resource
 * @param resource The hrn that identifies the resource.
 * @param availableToHrn The hrn of the project that the resource is made linkable against or
 * The hrn of the realm that the resource is made linkable against.
 * @param xCorrelationID Correlates HTTP requests between a client and server.
 * If not present in the incoming request, it will be generated.
 */
export async function getResourceLinkability(
    builder: RequestBuilder,
    params: {
        resource: string;
        availableToHrn: string;
        xCorrelationID?: string;
    }
): Promise<LinkableResource> {
    const baseUrl = "/resources/{resource}/linkable/{availableToHrn}"
        .replace("{resource}", UrlBuilder.toString(params["resource"]))
        .replace(
            "{availableToHrn}",
            UrlBuilder.toString(params["availableToHrn"])
        );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };
    if (params["xCorrelationID"] !== undefined) {
        headers["X-Correlation-ID"] = params["xCorrelationID"] as string;
    }

    return builder.request<LinkableResource>(urlBuilder, options);
}

/**
 * Get the list of Projects that the resource belongs to or is referenced in(linked to).
 * The returned list will only include projects that are in the caller's realm.
 *
 * @note
 * If the presented access token has a project scope, the response will include:
 * - The home project of the resource
 * - The list of Projects that the resource has been made linkable to
 * - The include the list of Projects that the resource has been linked to
 *
 * If the presented access token has no scope, the response will include:
 * - The list of Projects filtered out based on the membership of the caller.
 *
 * Access Control for project scoped call:
 * * The calling principal **must** have permission to take all the "requiredToMakeLinkable" actions against
 * the service inferred via the reserved resource prefix of the resource in the path in the scope of the   home project of the resource.
 *
 * * Example: In order to make a catalog linkable, the following permission would be required:
 * * "action" : "manageResource"
 * * "resource" : "hrn:here:data::olp-here:my-shared-catalog"
 *
 * @summary Get the requested Projects that the resource belongs to or is referenced in(linked to)
 * @param resource The hrn that identifies the resource.
 * @param pageToken The cursor for pagination. Present only if there is an additional page of data to view.
 * @param limit Number of entries to be returned in the response.
 * @param relation The relation of the resource. A resource is only returned in the response if it matches the requested relation.
 * @param xCorrelationID Correlates HTTP requests between a client and server.
 * If not present in the incoming request, it will be generated.
 */
export async function getResourceProjects(
    builder: RequestBuilder,
    params: {
        resource: string;
        pageToken?: string;
        limit?: number;
        relation?: Relation;
        xCorrelationID?: string;
    }
): Promise<ResourceProjectListWithPageToken> {
    const baseUrl = "/resources/{resource}/projects".replace(
        "{resource}",
        UrlBuilder.toString(params["resource"])
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("limit", params["limit"]);
    urlBuilder.appendQuery("pageToken", params["pageToken"]);
    urlBuilder.appendQuery("relation", params["relation"]);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };
    if (params["xCorrelationID"] !== undefined) {
        headers["X-Correlation-ID"] = params["xCorrelationID"] as string;
    }

    return builder.request<ResourceProjectListWithPageToken>(
        urlBuilder,
        options
    );
}

/**
 * Get a list of Resources that the caller is allowed to see based on the input query parameters.
 *
 * @note
 * If the presented access token has a project scope:
 * - The response will only include resources from that project or,
 * - If referenceable=true or linkable=true, the response will include the resources that are available to the caller to
 * link to the project in the token's project scope.
 *
 * - If the presented access token has no scope:
 * - The response will include resources from all projects that the caller has access to.
 * - For type='catalog' the response will also include resources that exist outside of any project.
 * - For all other types, the response will NOT include resources that exist outside of any project.
 * - For referenceable=true or linkable=true, the response will ONLY include the HERE public resources that are available
 * to the caller to link to ANY project * This API works with tokens that are scoped and not scoped to a project.
 *
 * @summary Get a list of resources
 * @param type The type of the resource.
 * @param limit Number of entries to be returned in the response.
 * @param pageToken The cursor for pagination. Present only if there is an additional page of data to view.
 * @param access Filter the resources accessible to the caller based on the access types.
 * The default value is "default".
 * Not applicable to use along with the query parameter "referenceable": "true" or "linkable": "true"
 * If "default" includes resources where:
 * - The user has access to the resource"s home project OR
 * - The user has access to a project that the resource is linked to as a reference OR
 * - The type": ""catalog" and the resource is not in any project and the user has "read" access to it OR
 * - The type": ""catalog" and the resource is not in any project and the user has "write" access to it OR
 * - The type": ""catalog" and the resource is not in any project and the user has "manage" access to it.
 *
 * If "manage" includes resources where:
 * - The user has access to the resource"s home project OR
 * - The type": ""catalog" and the resource is not in any project and the user has "manage" access to it.
 *
 * @param referenceable Get all referenceable(linkable) resources available to the caller to attach as a reference(link) to projects.
 * Only supported value is true. Note - Can be used as a synonym for linkable  A resource is referenceable(linkable) if it is marked
 * as referenceable:
 * - and the caller has permission to all reference enabled actions against the resource or,
 * - in case of a project scoped token, the caller has effective membership on the projects to attach resources
 * as a reference(link) to the Project.
 *
 * @param linkable Get all linkable resources available to the caller to attach as a link to project.
 * Only supported value is true. Note - Can be used as a synonym for referenceable
 * @param xCorrelationID Correlates HTTP requests between a client and server.
 * If not present in the incoming request, it will be generated.
 */
export async function getResources(
    builder: RequestBuilder,
    params: {
        type: Type;
        limit?: number;
        pageToken?: string;
        access?: string;
        referenceable?: boolean;
        linkable?: boolean;
        xCorrelationID?: string;
    }
): Promise<ResourceListDetailedWithPageToken> {
    const baseUrl = "/resources";

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("limit", params["limit"]);
    urlBuilder.appendQuery("pageToken", params["pageToken"]);
    urlBuilder.appendQuery("type", params["type"]);
    urlBuilder.appendQuery("access", params["access"]);
    urlBuilder.appendQuery("referenceable", `${params["referenceable"]}`);
    urlBuilder.appendQuery("linkable", `${params["linkable"]}`);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };
    if (params["xCorrelationID"] !== undefined) {
        headers["X-Correlation-ID"] = params["xCorrelationID"] as string;
    }

    return builder.request<ResourceListDetailedWithPageToken>(
        urlBuilder,
        options
    );
}

/**
 * Get List of all the resources in the realm of the caller
 *
 * Access Control:
 * * User Access Token & Client Access Token
 * * The calling principal **must** have permission to take the **listRealmResources** action for the specified resource.
 *
 * * Example:
 * In order to get a list of projects, the following permission would be required:
 * * "action" : "listRealmResources"
 *
 * This API works only with tokens that are scoped to a project.
 *
 * @summary Get List of all the resources in the realm of the caller
 * @param limit Number of entries to be returned in the response.
 * @param pageToken The cursor for pagination. Present only if there is an additional page of data to view.
 * @param type The type of the resource.
 * @param xCorrelationID Correlates HTTP requests between a client and server.
 * If not present in the incoming request, it will be generated.
 */
export async function listRealmResources(
    builder: RequestBuilder,
    params: {
        limit?: number;
        pageToken?: string;
        type?: Type;
        xCorrelationID?: string;
    }
): Promise<ResourceListWithPageToken> {
    const baseUrl = "/realm/resources";

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("limit", params["limit"]);
    urlBuilder.appendQuery("pageToken", params["pageToken"]);
    urlBuilder.appendQuery("type", params["type"]);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };
    if (params["xCorrelationID"] !== undefined) {
        headers["X-Correlation-ID"] = params["xCorrelationID"] as string;
    }

    return builder.request<ResourceListWithPageToken>(urlBuilder, options);
}

/**
 * Adds a listing to make this resource linkable to either a project or entire realm.
 *
 * The resource must belong to a project to be made linkable. Either projectHrn or realmHrn must be provided to make the resource
 * linkable to.
 *
 * Access Control:
 * * The calling principal **must** have permission to take all the "requiredToMakeLinkable" actions against
 * the service inferred via the reserved resource prefix of the resource in the path in the scope of the   home project of the resource.
 *
 * * Example:
 * In order to make a catalog linkable, the following permission would be required:
 * * "action" : "manageResource"
 * * "resource" : "hrn:here:data::olp-here:my-shared-catalog"
 *
 * This API works only with tokens that are scoped to the home project of the resource.
 *
 * @summary Make a resource Linkable
 * @param body
 * @param resource The hrn that identifies the resource.
 * @param xCorrelationID Correlates HTTP requests between a client and server.
 * If not present in the incoming request, it will be generated.
 */
export async function makeResourceLinkable(
    builder: RequestBuilder,
    params: {
        body: LinkableResource;
        resource: string;
        xCorrelationID?: string;
    }
): Promise<LinkableResource> {
    const baseUrl = "/resources/{resource}/linkable".replace(
        "{resource}",
        UrlBuilder.toString(params["resource"])
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "POST",
        headers
    };
    headers["Content-Type"] = "application/json";
    if (params["body"] !== undefined) {
        options.body = JSON.stringify(params["body"]);
    }
    if (params["xCorrelationID"] !== undefined) {
        headers["X-Correlation-ID"] = params["xCorrelationID"] as string;
    }

    return builder.request<LinkableResource>(urlBuilder, options);
}

/**
 * Remove the linkability of this resource against the requested project or realm.
 *
 * @note This action does not have any impact on pre-existing links.
 *
 * Access Control:
 * * The calling principal **must** have permission to take all the "requiredToMakeLinkable" actions against
 * the service inferred via the reserved resource prefix of the resource in the path in the scope of the   home project of the resource.
 * * Example: In order to remove the catalog linkability, the following permission would be required:
 * * "action" : "manageResource"
 * * "resource" : "hrn:here:data::olp-here:my-shared-catalog"
 *
 * This API works only with tokens that are scoped to the home project of the resource.
 *
 * @summary Remove the linkability of a resource
 * @param resource The hrn that identifies the resource.
 * @param availableToHrn The hrn of the project that the resource is made linkable against or The hrn of the realm that the resource
 * is made linkable against.
 * @param xCorrelationID Correlates HTTP requests between a client and server.
 * If not present in the incoming request, it will be generated.
 */
export async function removeResourceLinkability(
    builder: RequestBuilder,
    params: {
        resource: string;
        availableToHrn: string;
        xCorrelationID?: string;
    }
): Promise<Response> {
    const baseUrl = "/resources/{resource}/linkable/{availableToHrn}"
        .replace("{resource}", UrlBuilder.toString(params["resource"]))
        .replace(
            "{availableToHrn}",
            UrlBuilder.toString(params["availableToHrn"])
        );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "DELETE",
        headers
    };
    if (params["xCorrelationID"] !== undefined) {
        headers["X-Correlation-ID"] = params["xCorrelationID"] as string;
    }

    return builder.requestBlob(urlBuilder, options);
}

/**
 * Update the linkability of this resource against the requested project or realm.
 *
 * Access Control:  * The calling principal **must** have permission to take all the "requiredToMakeLinkable" actions against
 * the service inferred via the reserved resource prefix of the resource in the path in the scope of the   home project of the resource.
 *
 * * Example:
 * In order to update the catalog linkability, the following permission would be required:
 * * "action" : "manageResource"
 * * "resource" : "hrn:here:data::olp-here:my-shared-catalog"
 *
 * This API works only with tokens that are scoped to the home project of the resource.
 *
 * @summary Update the linkability of a resource
 * @param body
 * @param resource The hrn that identifies the resource.
 * @param availableToHrn The hrn of the project that the resource is made linkable against or The hrn of the realm that the resource
 * is made linkable against.
 * @param xCorrelationID Correlates HTTP requests between a client and server.
 * If not present in the incoming request, it will be generated.
 */
export async function updateResourceLinkability(
    builder: RequestBuilder,
    params: {
        body: LinkableResource;
        resource: string;
        availableToHrn: string;
        xCorrelationID?: string;
    }
): Promise<LinkableResource> {
    const baseUrl = "/resources/{resource}/linkable/{availableToHrn}"
        .replace("{resource}", UrlBuilder.toString(params["resource"]))
        .replace(
            "{availableToHrn}",
            UrlBuilder.toString(params["availableToHrn"])
        );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "PUT",
        headers
    };
    headers["Content-Type"] = "application/json";
    if (params["body"] !== undefined) {
        options.body = JSON.stringify(params["body"]);
    }
    if (params["xCorrelationID"] !== undefined) {
        headers["X-Correlation-ID"] = params["xCorrelationID"] as string;
    }

    return builder.request<LinkableResource>(urlBuilder, options);
}

/**
 * Attaches the Project Policy to the member of the Project.
 *
 * Access Control:
 * * User Access Token & Client Access Token
 * * The calling principal **must** have permission to take the **manageMembers** action for the specified resource.
 *
 * * Example:
 * In order to attach a custom policy in a Project to a member, the following permissions would be required:
 * * "action" : "manageMembers"
 * * "resource" : "hrn:here:authorization::myrealm:project/my-project-0000"
 * AND
 * * "action" : "managePolicies"
 * * "resource" : "hrn:here:authorization::myrealm:project/my-project-0000"
 * * In the Project workflow, the above permission is granted to all Project Admins and Resource Managers
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Attach Project Policy to Member
 * @param project HRN identifying the project
 * @param member HRN identifying the project member. Either user, app or group
 * @param policy HRN identifying the project policy. For HERE provided policies,
 * the HRN format would be - hrn:here:authorization::myrealm:default:policy/read-only-access-to-all-catalogs
 */
export async function attachProjectPolicyToMember(
    builder: RequestBuilder,
    params: { project: string; member: string; policy: string }
): Promise<Response> {
    const baseUrl = "/projects/{project}/members/{member}/policies/{policy}"
        .replace("{project}", UrlBuilder.toString(params["project"]))
        .replace("{member}", UrlBuilder.toString(params["member"]))
        .replace("{policy}", UrlBuilder.toString(params["policy"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "POST",
        headers
    };

    return builder.requestBlob(urlBuilder, options);
}

/**
 * Create the requested custom policy in the Project
 *
 * Access Control:
 * * User Access Token & Client Access Token
 * * The calling principal **must** have permission to take the **managePolicies** action for the specified resource.
 *
 * * Example:
 * In order to create a custom policy in a Project, the following permission would be required:
 * * "action" : "managePolicies"
 * * "resource" : "hrn:here:authorization::myrealm:project/my-project-0000"
 * * In the Project workflow, the above permission is granted to all Project Admins and Resource Managers
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Create the requested Project Policy
 * @param body
 * @param project HRN identifying the project
 */
export async function createProjectPolicy(
    builder: RequestBuilder,
    params: { body: ProjectPolicyRequestBody; project: string }
): Promise<ProjectPolicyResponse> {
    const baseUrl = "/projects/{project}/policies".replace(
        "{project}",
        UrlBuilder.toString(params["project"])
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "POST",
        headers
    };
    headers["Content-Type"] = "application/json";
    if (params["body"] !== undefined) {
        options.body = JSON.stringify(params["body"]);
    }

    return builder.request<ProjectPolicyResponse>(urlBuilder, options);
}

/**
 * Delete the custom policy in the Project
 *
 * Access Control:
 * * User Access Token & Client Access Token
 * * The calling principal **must** have permission to take the **managePolicies** action for the specified resource.
 *
 * * Example:
 * In order to update a custom policy in a Project, the following permission would be required:
 * * "action" : "managePolicies"
 * * "resource" : "hrn:here:authorization::myrealm:project/my-project-0000"
 * * In the Project workflow, the above permission is granted to all Project Admins and Resource Managers
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Delete the custom Project Policy
 * @param project HRN identifying the project
 * @param policy HRN identifying the project policy. For HERE provided policies,
 * the HRN format would be - hrn:here:authorization::myrealm:default:policy/read-only-access-to-all-catalogs
 */
export async function deleteProjectPolicy(
    builder: RequestBuilder,
    params: { project: string; policy: string }
): Promise<Response> {
    const baseUrl = "/projects/{project}/policies/{policy}"
        .replace("{project}", UrlBuilder.toString(params["project"]))
        .replace("{policy}", UrlBuilder.toString(params["policy"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "DELETE",
        headers
    };

    return builder.requestBlob(urlBuilder, options);
}

/**
 * Detached the requested custom Project Policy from a Membber
 *
 * Access Control:
 * * User Access Token & Client Access Token
 * * The calling principal **must** have permission to take the **manageMembers** action for the specified resource.
 *
 * * Example:
 * In order to detach a custom policy in a Project from a member, the following permissions would be required:
 * * "action" : "manageMembers"
 * * "resource" : "hrn:here:authorization::myrealm:project/my-project-0000"
 * AND
 * * "action" : "managePolicies"
 * * "resource" : "hrn:here:authorization::myrealm:project/my-project-0000"
 * * In the Project workflow, the above permission is granted to all Project Admins and Resource Managers
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Detach the Project Policy from a Member
 * @param project HRN identifying the project
 * @param member HRN identifying the project member. Either user, app or group
 * @param policy HRN identifying the project policy. For HERE provided policies,
 * the HRN format would be - hrn:here:authorization::myrealm:default:policy/read-only-access-to-all-catalogs
 */
export async function detachProjectPolicyFromMember(
    builder: RequestBuilder,
    params: { project: string; member: string; policy: string }
): Promise<Response> {
    const baseUrl = "/projects/{project}/members/{member}/policies/{policy}"
        .replace("{project}", UrlBuilder.toString(params["project"]))
        .replace("{member}", UrlBuilder.toString(params["member"]))
        .replace("{policy}", UrlBuilder.toString(params["policy"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "DELETE",
        headers
    };

    return builder.requestBlob(urlBuilder, options);
}

/**
 * Get the list of all Project Members with the attached Policy
 *
 * Access Control:
 * * User Access Token & Client Access Token
 * * The calling principal **must** have permission to take the **read** action for the specified resource.
 *
 * * Example:
 * In order to read the list of all members attached to a project policy, the following permission would be required:
 * * "action" : "read"
 * * "resource" : "hrn:here:authorization::myrealm:project/my-project-0000"
 * * In the Project workflow, the above permission is granted to all Project Members, Project Admins, Org Admins
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Get the list of all Project Members with the attached Policy
 * @param project HRN identifying the project
 * @param policy HRN identifying the project policy. For HERE provided policies,
 * the HRN format would be - hrn:here:authorization::myrealm:default:policy/read-only-access-to-all-catalogs
 * @param xCorrelationID Correlates HTTP requests between a client and server. If not present in the incoming request,
 * it will be generated.
 * @param limit Number of entries to be returned in the response.
 * @param pageToken The cursor for pagination. Present only if there is an additional page of data to view.
 */
export async function getAllProjectMembersWithAttachedPolicy(
    builder: RequestBuilder,
    params: {
        project: string;
        policy: string;
        xCorrelationID?: string;
        limit?: number;
        pageToken?: string;
    }
): Promise<ProjectMemberListWithPageToken> {
    const baseUrl = "/projects/{project}/policies/{policy}/members"
        .replace("{project}", UrlBuilder.toString(params["project"]))
        .replace("{policy}", UrlBuilder.toString(params["policy"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("limit", params["limit"]);
    urlBuilder.appendQuery("pageToken", params["pageToken"]);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };
    if (params["xCorrelationID"] !== undefined) {
        headers["X-Correlation-ID"] = params["xCorrelationID"] as string;
    }

    return builder.request<ProjectMemberListWithPageToken>(urlBuilder, options);
}

/**
 * Get the list of Attached Project Policies For a Member
 *
 * Access Control:
 * * User Access Token & Client Access Token
 * * The calling principal **must** have permission to take the **read** action for the specified resource.
 *
 * * Example:
 * In order to read the list of the attached project policies, the following permission would be required:
 * * "action" : "read"
 * * "resource" : "hrn:here:authorization::myrealm:project/my-project-0000"
 * * In the Project workflow, the above permission is granted to all Project Members, Project Admins, Org Admins
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Get the list of Attached Project Policies For a Member
 * @param project HRN identifying the project
 * @param member HRN identifying the project member. Either user, app or group
 * @param xCorrelationID Correlates HTTP requests between a client and server.
 *  If not present in the incoming request, it will be generated.
 * @param limit Number of entries to be returned in the response.
 * @param pageToken The cursor for pagination. Present only if there is an additional page of data to view.
 */
export async function getAttachedProjectPoliciesForMember(
    builder: RequestBuilder,
    params: {
        project: string;
        member: string;
        xCorrelationID?: string;
        limit?: number;
        pageToken?: string;
    }
): Promise<ProjectPolicyListResponse> {
    const baseUrl = "/projects/{project}/members/{member}/policies"
        .replace("{project}", UrlBuilder.toString(params["project"]))
        .replace("{member}", UrlBuilder.toString(params["member"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("limit", params["limit"]);
    urlBuilder.appendQuery("pageToken", params["pageToken"]);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };
    if (params["xCorrelationID"] !== undefined) {
        headers["X-Correlation-ID"] = params["xCorrelationID"] as string;
    }

    return builder.request<ProjectPolicyListResponse>(urlBuilder, options);
}

/**
 * Get the attached Project Policy For a Member
 *
 * Access Control:
 * * User Access Token & Client Access Token
 * * The calling principal **must** have permission to take the **read** action for the specified resource.
 *
 * * Example:
 * In order to read the attached project policy, the following permission would be required:
 * * "action" : "read"
 * * "resource" : "hrn:here:authorization::myrealm:project/my-project-0000"
 * * In the Project workflow, the above permission is granted to all Project Members, Project Admins, Org Admins
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Get the attached Project Policy for a Member
 * @param project HRN identifying the project
 * @param member HRN identifying the project member. Either user, app or group
 * @param policy HRN identifying the project policy. For HERE provided policies,
 * the HRN format would be - hrn:here:authorization::myrealm:default:policy/read-only-access-to-all-catalogs
 */
export async function getAttachedProjectPolicyForMember(
    builder: RequestBuilder,
    params: { project: string; member: string; policy: string }
): Promise<AttachedPolicy> {
    const baseUrl = "/projects/{project}/members/{member}/policies/{policy}"
        .replace("{project}", UrlBuilder.toString(params["project"]))
        .replace("{member}", UrlBuilder.toString(params["member"]))
        .replace("{policy}", UrlBuilder.toString(params["policy"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<AttachedPolicy>(urlBuilder, options);
}

/**
 * Get the requested Project Policy
 *
 * Access Control:
 * * User Access Token & Client Access Token
 * * The calling principal **must** have permission to take the **read** action for the specified resource.
 *
 * * Example:
 * In order to read a project policy, the following permission would be required:
 * * "action" : "read"
 * * "resource" : "hrn:here:authorization::myrealm:project/my-project-0000"
 *  * In the Project workflow, the above permission is granted to all Project Members, Project Admins, Org Admins
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Get the Project Policy
 * @param project HRN identifying the project
 * @param policy HRN identifying the project policy. For HERE provided policies,
 * the HRN format would be - hrn:here:authorization::myrealm:default:policy/read-only-access-to-all-catalogs
 */
export async function getProjectPolicy(
    builder: RequestBuilder,
    params: { project: string; policy: string }
): Promise<ProjectPolicyResponse> {
    const baseUrl = "/projects/{project}/policies/{policy}"
        .replace("{project}", UrlBuilder.toString(params["project"]))
        .replace("{policy}", UrlBuilder.toString(params["policy"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };

    return builder.request<ProjectPolicyResponse>(urlBuilder, options);
}

/**
 * List the Policies that can be attached to members of the Project.
 * This list will contain all the HERE provided policies and any custom user defined policies created in the Project.
 *
 * Access Control:
 * * User Access Token & Client Access Token
 * * The calling principal **must** have permission to take the **read** action for the specified resource.
 *
 * * Example:
 * In order to read a policy list of a Project, the following permission would be required:
 * * "action" : "read"
 * * "resource" : "hrn:here:authorization::myrealm:project/my-project-0000"
 * * In the Project workflow, the above permission is granted to all Project Members, Project Admins, Org Admins
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary List the Policies in a Project
 * @param project HRN identifying the project
 * @param xCorrelationID Correlates HTTP requests between a client and server. If not present in the incoming request,
 * it will be generated.
 * @param projectPolicyType The type of the Project Policy
 * @param limit Number of entries to be returned in the response.
 * @param pageToken The cursor for pagination. Present only if there is an additional page of data to view.
 */
export async function getProjectPolicyList(
    builder: RequestBuilder,
    params: {
        project: string;
        xCorrelationID?: string;
        projectPolicyType?: string;
        limit?: number;
        pageToken?: string;
    }
): Promise<ProjectPolicyListResponse> {
    const baseUrl = "/projects/{project}/policies".replace(
        "{project}",
        UrlBuilder.toString(params["project"])
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("projectPolicyType", params["projectPolicyType"]);
    urlBuilder.appendQuery("limit", params["limit"]);
    urlBuilder.appendQuery("pageToken", params["pageToken"]);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };
    if (params["xCorrelationID"] !== undefined) {
        headers["X-Correlation-ID"] = params["xCorrelationID"] as string;
    }

    return builder.request<ProjectPolicyListResponse>(urlBuilder, options);
}

/**
 * Sets the Attached Policies list for the specified Project Member, overwriting any pre-existing Attached Policies.
 * The request body will replace any pre-existing Policy attachment(s), and replace that list with those Policies
 * identified in the request body.
 *
 * Access Control:
 * * User Access Token & Client Access Token
 * * The calling principal **must** have permission to take the **manageMembers** action for the specified resource.
 *
 * * Example:
 * In order to attach a custom policy in a Project to a member, the following permissions would be required:
 * * "action" : "manageMembers"
 * * "resource" : "hrn:here:authorization::myrealm:project/my-project-0000"      AND      * "action" : "managePolicies"
 * * "resource" : "hrn:here:authorization::myrealm:project/my-project-0000"
 * * In the Project workflow, the above permission is granted to all Project Admins and Resource Managers
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Set Attached Policies for Member
 * @param body
 * @param project HRN identifying the project
 * @param member HRN identifying the project member. Either user, app or group
 */
export async function setAttachedProjectPoliciesToMember(
    builder: RequestBuilder,
    params: { body: AttachedPolicy[]; project: string; member: string }
): Promise<AttachedPolicy[]> {
    const baseUrl = "/projects/{project}/members/{member}/policies"
        .replace("{project}", UrlBuilder.toString(params["project"]))
        .replace("{member}", UrlBuilder.toString(params["member"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "POST",
        headers
    };
    headers["Content-Type"] = "application/json";
    if (params["body"] !== undefined) {
        options.body = JSON.stringify(params["body"]);
    }

    return builder.request<AttachedPolicy[]>(urlBuilder, options);
}

/**
 * Update the requested custom policy in the Project
 *
 * Access Control:
 * * User Access Token & Client Access Token
 * * The calling principal **must** have permission to take the **managePolicies** action for the specified resource.
 *
 * * Example:
 * In order to update a custom policy in a Project, the following permission would be required:
 * * "action" : "managePolicies"
 * * "resource" : "hrn:here:authorization::myrealm:project/my-project-0000"
 * * In the Project workflow, the above permission is granted to all Project Admins and Resource Managers
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Update the requested Project Policy
 * @param body
 * @param project HRN identifying the project
 * @param policy HRN identifying the project policy. For HERE provided policies,
 * the HRN format would be - hrn:here:authorization::myrealm:default:policy/read-only-access-to-all-catalogs
 */
export async function updateProjectPolicy(
    builder: RequestBuilder,
    params: { body: ProjectPolicyRequestBody; project: string; policy: string }
): Promise<ProjectPolicyResponse> {
    const baseUrl = "/projects/{project}/policies/{policy}"
        .replace("{project}", UrlBuilder.toString(params["project"]))
        .replace("{policy}", UrlBuilder.toString(params["policy"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "PUT",
        headers
    };
    headers["Content-Type"] = "application/json";
    if (params["body"] !== undefined) {
        options.body = JSON.stringify(params["body"]);
    }

    return builder.request<ProjectPolicyResponse>(urlBuilder, options);
}

/**
 * Gets the actions list for the resource for the project based on the query parameters.
 *
 * The list of available actions are filtered based on the relation of the resource, either home or reference with the allowed actions.
 * This API provides a list of available actions during project workflows like linking or project policy creation.
 *
 * Access Control:
 * * User Access Token & Client Access Token
 * * The calling principal **must** have permission to take the **read** action for the specified project
 *
 * * Example:
 * In order to get resource "hrn:here:data::myrealm:my-catalog-0000" in the project
 * "hrn:here:authorization::myrealm:project/my-project-0000", the following permission would be required:
 * * "action" : "read"
 * * "resource" : "hrn:here:authorization::myrealm:project/my-project-0000"
 * * This API works only with tokens that are not scoped to a project.
 *
 * @summary Get a list of actions that are allowed for the project resource
 * @param project HRN identifying the project
 * @param resource The hrn that identifies the resource.
 * @param type The type of action for the resource type.
 * - linkable : Actions that are allowed to be linked
 * - projectEnabled : Actions that are enabled for Projects access
 * - requiredToMakeLinkable : Actions that are required when an identity is making a resource linkable to a realm or other projects
 * @param xCorrelationID Correlates HTTP requests between a client and server.
 * If not present in the incoming request, it will be generated.
 */
export async function getResourceActionsForProject(
    builder: RequestBuilder,
    params: {
        project: string;
        resource: string;
        type: string;
        xCorrelationID?: string;
    }
): Promise<string[]> {
    const baseUrl = "/projects/{project}/resources/{resource}/actions"
        .replace("{project}", UrlBuilder.toString(params["project"]))
        .replace("{resource}", UrlBuilder.toString(params["resource"]));

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("type", params["type"]);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };
    if (params["xCorrelationID"] !== undefined) {
        headers["X-Correlation-ID"] = params["xCorrelationID"] as string;
    }

    return builder.request<string[]>(urlBuilder, options);
}

/**
 * Gets the actions list for the resource type based on the query parameters.
 *
 * @summary Get a list of actions for the resource type
 * @param resourceType The type of the resource.
 * @param type The type of action for the resource type.
 * - linkable : Actions that are allowed to be linked
 * - projectEnabled : Actions that are enabled for Projects access
 * - requiredToMakeLinkable : Actions that are required when an identity is making a resource linkable to a realm or other projects
 * @param xCorrelationID Correlates HTTP requests between a client and server.
 * If not present in the incoming request, it will be generated.
 */
export async function getResourceTypeActionList(
    builder: RequestBuilder,
    params: { resourceType: Type; type: string; xCorrelationID?: string }
): Promise<string[]> {
    const baseUrl = "/resourceTypes/{resourceType}/actions".replace(
        "{resourceType}",
        UrlBuilder.toString(params["resourceType"])
    );

    const urlBuilder = new UrlBuilder(builder.baseUrl + baseUrl);
    urlBuilder.appendQuery("type", params["type"]);

    const headers: { [header: string]: string } = {};
    const options: RequestOptions = {
        method: "GET",
        headers
    };
    if (params["xCorrelationID"] !== undefined) {
        headers["X-Correlation-ID"] = params["xCorrelationID"] as string;
    }

    return builder.request<string[]>(urlBuilder, options);
}
